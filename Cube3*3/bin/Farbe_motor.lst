   1              		.arch armv5te
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 2
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"Farbe_motor.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	Farbe_init
  19              	Farbe_init:
  20              		.fnstart
  21              	.LFB21:
  22              		.file 1 "Farbe_motor.c"
   1:Farbe_motor.c **** //
   2:Farbe_motor.c **** //  Farbe_motor.c
   3:Farbe_motor.c **** //  Cube3*3
   4:Farbe_motor.c **** //
   5:Farbe_motor.c **** //  Created by 杨春霞 on 12.11.15.
   6:Farbe_motor.c **** //  Copyright © 2015 Chunxia Yang. All rights reserved.
   7:Farbe_motor.c **** //
   8:Farbe_motor.c **** 
   9:Farbe_motor.c **** #include <fcntl.h>
  10:Farbe_motor.c **** #include <stdio.h>
  11:Farbe_motor.c **** #include <sys/mman.h>
  12:Farbe_motor.c **** #ifdef __linux__
  13:Farbe_motor.c **** #include "lms2012.h"
  14:Farbe_motor.c **** #include "../lms2012/c_output.h"
  15:Farbe_motor.c **** #endif
  16:Farbe_motor.c **** #include <unistd.h>
  17:Farbe_motor.c **** #include <stdlib.h>
  18:Farbe_motor.c **** 
  19:Farbe_motor.c **** #include "Farbe_motor.h"
  20:Farbe_motor.c **** 
  21:Farbe_motor.c **** #ifdef __linux__
  22:Farbe_motor.c **** const int MOTOR_SPEED_D=30; //power:0~100
  23:Farbe_motor.c **** const char MOTOR_PORT_D = 0x08; //Schwenkbarer Farbensensor Motor;
  24:Farbe_motor.c **** #if 0
  25:Farbe_motor.c **** MOTORDATA *pMotorData;
  26:Farbe_motor.c **** int motor_file;
  27:Farbe_motor.c **** int encoder_file;
  28:Farbe_motor.c **** #else
  29:Farbe_motor.c **** OUTPUT_GLOBALS OutputInstance;
  30:Farbe_motor.c **** #endif
  31:Farbe_motor.c **** int Farbe_referenz=0;
  32:Farbe_motor.c **** int Farbe_ist=0;
  33:Farbe_motor.c **** const int Farbe_winkel[]={4,-745,-645,-640,-610,-590,-400};//690------695 veraenderung(2,4 weg) 755
  34:Farbe_motor.c **** //const int Farbe_winkel[]={4,-720,-640,-625,-600,-580,-400};//690------695 veraenderung
  35:Farbe_motor.c **** #endif
  36:Farbe_motor.c **** 
  37:Farbe_motor.c **** int Farbe_init()
  38:Farbe_motor.c **** {
  23              		.loc 1 38 0
  24              		.cfi_startproc
  25              		@ args = 0, pretend = 0, frame = 0
  26              		@ frame_needed = 0, uses_anonymous_args = 0
  27 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  28              		.save {r4, r5, r6, lr}
  29              		.cfi_def_cfa_offset 16
  30              		.cfi_offset 4, -16
  31              		.cfi_offset 5, -12
  32              		.cfi_offset 6, -8
  33              		.cfi_offset 14, -4
  39:Farbe_motor.c **** #ifdef __linux__
  40:Farbe_motor.c **** #if 0
  41:Farbe_motor.c ****     if ((motor_file = open(PWM_DEVICE_NAME, O_WRONLY))== -1)
  42:Farbe_motor.c ****     {
  43:Farbe_motor.c ****         printf("Failed to open device\n");
  44:Farbe_motor.c ****         return -1;
  45:Farbe_motor.c ****     }
  46:Farbe_motor.c ****     
  47:Farbe_motor.c ****     if((encoder_file = open(MOTOR_DEVICE_NAME, O_RDWR | O_SYNC)) == -1)
  48:Farbe_motor.c ****         return -1;
  49:Farbe_motor.c ****     pMotorData = (MOTORDATA*)mmap (0, sizeof(MOTORDATA)*vmOUTPUTS, PROT_READ|PROT_WRITE,MAP_FILE|MA
  50:Farbe_motor.c ****     
  51:Farbe_motor.c ****     if (pMotorData == MAP_FAILED)
  52:Farbe_motor.c ****     {
  53:Farbe_motor.c ****         printf("Map failed\n");
  54:Farbe_motor.c ****         return -1;
  55:Farbe_motor.c ****     }
  56:Farbe_motor.c ****     
  57:Farbe_motor.c ****     char motor_command[4];
  58:Farbe_motor.c ****     motor_command[0]=opOUTPUT_SET_TYPE;
  59:Farbe_motor.c ****     motor_command[1]=MOTOR_PORT_D;
  60:Farbe_motor.c ****     motor_command[2]=TYPE_MINITACHO;
  61:Farbe_motor.c ****     write(motor_file,motor_command,3);// motor_speed Wert geben
  62:Farbe_motor.c ****     
  63:Farbe_motor.c ****     motor_command[0]=opOUTPUT_SPEED;
  64:Farbe_motor.c ****     motor_command[1]=MOTOR_PORT_D;
  65:Farbe_motor.c ****     motor_command[2]=MOTOR_SPEED_D;
  66:Farbe_motor.c ****     write(motor_file,motor_command,3);// motor_speed Wert geben
  67:Farbe_motor.c ****     
  68:Farbe_motor.c ****     motor_command[0]=opOUTPUT_START;
  69:Farbe_motor.c ****     motor_command[1]=MOTOR_PORT_D;
  70:Farbe_motor.c ****     write(motor_file,motor_command,2);// Motor starten
  71:Farbe_motor.c ****     
  72:Farbe_motor.c ****     int old_TachoSensor;
  73:Farbe_motor.c ****     old_TachoSensor=pMotorData[3].TachoSensor;
  74:Farbe_motor.c ****     usleep(2*1000000);
  75:Farbe_motor.c ****     while(old_TachoSensor!=pMotorData[3].TachoSensor){
  76:Farbe_motor.c ****         printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[3].Speed, pMotorData[3].TachoCounts, pMotorD
  77:Farbe_motor.c ****         old_TachoSensor=pMotorData[3].TachoSensor;
  78:Farbe_motor.c ****         usleep(1000);
  79:Farbe_motor.c ****     }
  80:Farbe_motor.c ****     
  81:Farbe_motor.c ****     motor_command[0]=opOUTPUT_STOP;
  82:Farbe_motor.c ****     motor_command[1]=MOTOR_PORT_D;
  83:Farbe_motor.c ****     write(motor_file,motor_command,2);  // Motor stoppen
  84:Farbe_motor.c **** #else
  85:Farbe_motor.c ****     cOutputInit();
  34              		.loc 1 85 0
  35 0004 FEFFFFEB 		bl	cOutputInit
  36              	.LVL0:
  86:Farbe_motor.c ****     cOutputSetType(3,TYPE_MINITACHO);
  37              		.loc 1 86 0
  38 0008 0300A0E3 		mov	r0, #3
  39 000c 0810A0E3 		mov	r1, #8
  40 0010 FEFFFFEB 		bl	cOutputSetType
  41              	.LVL1:
  87:Farbe_motor.c ****     cOutputSpeed(MOTOR_PORT_D,MOTOR_SPEED_D);
  42              		.loc 1 87 0
  43 0014 0800A0E3 		mov	r0, #8
  44 0018 1E10A0E3 		mov	r1, #30
  45 001c FEFFFFEB 		bl	cOutputSpeed
  46              	.LVL2:
  88:Farbe_motor.c ****     cOutputStart(MOTOR_PORT_D);
  47              		.loc 1 88 0
  48 0020 0800A0E3 		mov	r0, #8
  49 0024 FEFFFFEB 		bl	cOutputStart
  50              	.LVL3:
  89:Farbe_motor.c ****     int old_TachoSensor;
  90:Farbe_motor.c ****     old_TachoSensor=cOutputGetCount(3);
  51              		.loc 1 90 0
  52 0028 0300A0E3 		mov	r0, #3
  53 002c FEFFFFEB 		bl	cOutputGetCount
  54              	.LVL4:
  55 0030 0050A0E1 		mov	r5, r0
  56              	.LVL5:
  91:Farbe_motor.c ****     usleep(2*1000000);
  57              		.loc 1 91 0
  58 0034 68009FE5 		ldr	r0, .L4
  59              	.LVL6:
  60 0038 FEFFFFEB 		bl	usleep
  61              	.LVL7:
  92:Farbe_motor.c ****     while(old_TachoSensor!=cOutputGetCount(3)){
  62              		.loc 1 92 0
  63 003c 0340A0E3 		mov	r4, #3
  93:Farbe_motor.c ****         old_TachoSensor=cOutputGetCount(3);
  94:Farbe_motor.c ****         usleep(1000);
  64              		.loc 1 94 0
  65 0040 FA6FA0E3 		mov	r6, #1000
  92:Farbe_motor.c ****     while(old_TachoSensor!=cOutputGetCount(3)){
  66              		.loc 1 92 0
  67 0044 040000EA 		b	.L2
  68              	.L3:
  93:Farbe_motor.c ****         old_TachoSensor=cOutputGetCount(3);
  69              		.loc 1 93 0
  70 0048 0400A0E1 		mov	r0, r4
  71 004c FEFFFFEB 		bl	cOutputGetCount
  72              	.LVL8:
  73 0050 0050A0E1 		mov	r5, r0
  74              	.LVL9:
  75              		.loc 1 94 0
  76 0054 0600A0E1 		mov	r0, r6
  77              	.LVL10:
  78 0058 FEFFFFEB 		bl	usleep
  79              	.LVL11:
  80              	.L2:
  92:Farbe_motor.c ****     while(old_TachoSensor!=cOutputGetCount(3)){
  81              		.loc 1 92 0 discriminator 1
  82 005c 0400A0E1 		mov	r0, r4
  83 0060 FEFFFFEB 		bl	cOutputGetCount
  84              	.LVL12:
  85 0064 050050E1 		cmp	r0, r5
  86 0068 F6FFFF1A 		bne	.L3
  95:Farbe_motor.c ****     }
  96:Farbe_motor.c ****     cOutputStop(MOTOR_PORT_D,1);
  87              		.loc 1 96 0
  88 006c 0800A0E3 		mov	r0, #8
  89 0070 0110A0E3 		mov	r1, #1
  90 0074 FEFFFFEB 		bl	cOutputStop
  91              	.LVL13:
  97:Farbe_motor.c **** #endif
  98:Farbe_motor.c ****     Farbe_referenz=cOutputGetCount(3);
  92              		.loc 1 98 0
  93 0078 0300A0E3 		mov	r0, #3
  94 007c FEFFFFEB 		bl	cOutputGetCount
  95              	.LVL14:
  96 0080 0010A0E1 		mov	r1, r0
  97 0084 1C309FE5 		ldr	r3, .L4+4
  98 0088 000083E5 		str	r0, [r3]
  99:Farbe_motor.c ****     Farbe_ist = 0;
  99              		.loc 1 99 0
 100 008c 0040A0E3 		mov	r4, #0
 101 0090 044083E5 		str	r4, [r3, #4]
 100:Farbe_motor.c ****     printf("Farbe_referenzPosition angefahren %d\n\r",Farbe_referenz);
 102              		.loc 1 100 0
 103 0094 10009FE5 		ldr	r0, .L4+8
 104 0098 FEFFFFEB 		bl	printf
 105              	.LVL15:
 101:Farbe_motor.c ****     //Farbe_setpos(0);
 102:Farbe_motor.c **** #endif
 103:Farbe_motor.c ****     return 0;
 104:Farbe_motor.c **** }
 106              		.loc 1 104 0
 107 009c 0400A0E1 		mov	r0, r4
 108 00a0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 109              	.L5:
 110              		.align	2
 111              	.L4:
 112 00a4 80841E00 		.word	2000000
 113 00a8 00000000 		.word	.LANCHOR0
 114 00ac 00000000 		.word	.LC0
 115              		.cfi_endproc
 116              	.LFE21:
 117              		.fnend
 119              		.align	2
 120              		.global	Farbe_setpos
 122              	Farbe_setpos:
 123              		.fnstart
 124              	.LFB22:
 105:Farbe_motor.c **** 
 106:Farbe_motor.c **** 
 107:Farbe_motor.c **** int Farbe_setpos(int Farbe_soll)
 108:Farbe_motor.c **** {
 125              		.loc 1 108 0
 126              		.cfi_startproc
 127              		@ args = 0, pretend = 0, frame = 0
 128              		@ frame_needed = 0, uses_anonymous_args = 0
 129              	.LVL16:
 130 00b0 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 131              		.save {r4, r5, r6, r7, r8, lr}
 132              		.cfi_def_cfa_offset 24
 133              		.cfi_offset 4, -24
 134              		.cfi_offset 5, -20
 135              		.cfi_offset 6, -16
 136              		.cfi_offset 7, -12
 137              		.cfi_offset 8, -8
 138              		.cfi_offset 14, -4
 139 00b4 0070A0E1 		mov	r7, r0
 109:Farbe_motor.c **** #ifdef __linux__
 110:Farbe_motor.c **** #if 0
 111:Farbe_motor.c ****     char motor_command[4];
 112:Farbe_motor.c ****     motor_command[0]=opOUTPUT_SPEED;
 113:Farbe_motor.c ****     motor_command[1]=MOTOR_PORT_D;
 114:Farbe_motor.c ****     if(Farbe_winkel[Farbe_ist]<Farbe_winkel[Farbe_soll])
 115:Farbe_motor.c ****     {
 116:Farbe_motor.c ****         motor_command[2]=MOTOR_SPEED_D;
 117:Farbe_motor.c ****         write(motor_file,motor_command,3);  //motor_speed Wert geben
 118:Farbe_motor.c ****         
 119:Farbe_motor.c ****         motor_command[0]=opOUTPUT_START;
 120:Farbe_motor.c ****         motor_command[1]=MOTOR_PORT_D;
 121:Farbe_motor.c ****         write(motor_file,motor_command,2);  //Motor starten
 122:Farbe_motor.c ****         
 123:Farbe_motor.c ****         while ((OutputInstance.MotorData[3].TachoSensor-Farbe_referenz) < Farbe_winkel[Farbe_soll])
 124:Farbe_motor.c ****         {
 125:Farbe_motor.c ****             //printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[3].Speed, pMotorData[3].TachoCounts, p
 126:Farbe_motor.c ****             usleep(1000);
 127:Farbe_motor.c ****         }
 128:Farbe_motor.c ****     }
 129:Farbe_motor.c ****     else
 130:Farbe_motor.c ****     {
 131:Farbe_motor.c ****         motor_command[2]=-MOTOR_SPEED_D;
 132:Farbe_motor.c ****         write(motor_file,motor_command,3);  //motor_speed Wert geben
 133:Farbe_motor.c ****         
 134:Farbe_motor.c ****         motor_command[0]=opOUTPUT_START;
 135:Farbe_motor.c ****         motor_command[1]=MOTOR_PORT_D;
 136:Farbe_motor.c ****         write(motor_file,motor_command,2);  //Motor starten
 137:Farbe_motor.c ****         
 138:Farbe_motor.c ****         
 139:Farbe_motor.c ****         while ((OutputInstance.MotorData[3].TachoSensor-Farbe_referenz) > Farbe_winkel[Farbe_soll])
 140:Farbe_motor.c ****         {
 141:Farbe_motor.c ****             //printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[3].Speed, pMotorData[3].TachoCounts, p
 142:Farbe_motor.c ****             usleep(1000);
 143:Farbe_motor.c ****         }
 144:Farbe_motor.c ****     }
 145:Farbe_motor.c ****     
 146:Farbe_motor.c ****     motor_command[0]=opOUTPUT_STOP;
 147:Farbe_motor.c ****     motor_command[1]=MOTOR_PORT_D;
 148:Farbe_motor.c ****     write(motor_file,motor_command,2); //Motor stopppen
 149:Farbe_motor.c **** #else
 150:Farbe_motor.c ****     
 151:Farbe_motor.c ****     if(Farbe_winkel[Farbe_ist]<Farbe_winkel[Farbe_soll])
 140              		.loc 1 151 0
 141 00b8 BC309FE5 		ldr	r3, .L13
 142 00bc 004193E7 		ldr	r4, [r3, r0, asl #2]
 143 00c0 B8209FE5 		ldr	r2, .L13+4
 144 00c4 042092E5 		ldr	r2, [r2, #4]
 145 00c8 023193E7 		ldr	r3, [r3, r2, asl #2]
 146 00cc 040053E1 		cmp	r3, r4
 147 00d0 110000AA 		bge	.L7
 152:Farbe_motor.c ****     {
 153:Farbe_motor.c ****         cOutputSpeed(MOTOR_PORT_D,MOTOR_SPEED_D);
 148              		.loc 1 153 0
 149 00d4 0800A0E3 		mov	r0, #8
 150              	.LVL17:
 151 00d8 1E10A0E3 		mov	r1, #30
 152 00dc FEFFFFEB 		bl	cOutputSpeed
 153              	.LVL18:
 154:Farbe_motor.c ****         cOutputStart(MOTOR_PORT_D);
 154              		.loc 1 154 0
 155 00e0 0800A0E3 		mov	r0, #8
 156 00e4 FEFFFFEB 		bl	cOutputStart
 157              	.LVL19:
 155:Farbe_motor.c ****         
 156:Farbe_motor.c ****         while ((cOutputGetCount(3)-Farbe_referenz) < Farbe_winkel[Farbe_soll])
 158              		.loc 1 156 0
 159 00e8 0360A0E3 		mov	r6, #3
 160 00ec 8C509FE5 		ldr	r5, .L13+4
 157:Farbe_motor.c ****         {
 158:Farbe_motor.c ****             usleep(1000);
 161              		.loc 1 158 0
 162 00f0 FA8FA0E3 		mov	r8, #1000
 156:Farbe_motor.c ****         {
 163              		.loc 1 156 0
 164 00f4 010000EA 		b	.L8
 165              	.L9:
 166              		.loc 1 158 0
 167 00f8 0800A0E1 		mov	r0, r8
 168 00fc FEFFFFEB 		bl	usleep
 169              	.LVL20:
 170              	.L8:
 156:Farbe_motor.c ****         {
 171              		.loc 1 156 0 discriminator 1
 172 0100 0600A0E1 		mov	r0, r6
 173 0104 FEFFFFEB 		bl	cOutputGetCount
 174              	.LVL21:
 175 0108 003095E5 		ldr	r3, [r5]
 176 010c 000063E0 		rsb	r0, r3, r0
 177 0110 000054E1 		cmp	r4, r0
 178 0114 F7FFFFCA 		bgt	.L9
 179 0118 100000EA 		b	.L10
 180              	.LVL22:
 181              	.L7:
 159:Farbe_motor.c ****         }
 160:Farbe_motor.c ****     }
 161:Farbe_motor.c ****     else
 162:Farbe_motor.c ****     {
 163:Farbe_motor.c ****         cOutputSpeed(MOTOR_PORT_D,-MOTOR_SPEED_D);
 182              		.loc 1 163 0
 183 011c 0800A0E3 		mov	r0, #8
 184              	.LVL23:
 185 0120 1D10E0E3 		mvn	r1, #29
 186 0124 FEFFFFEB 		bl	cOutputSpeed
 187              	.LVL24:
 164:Farbe_motor.c ****         cOutputStart(MOTOR_PORT_D);
 188              		.loc 1 164 0
 189 0128 0800A0E3 		mov	r0, #8
 190 012c FEFFFFEB 		bl	cOutputStart
 191              	.LVL25:
 165:Farbe_motor.c ****    
 166:Farbe_motor.c ****         while ((cOutputGetCount(3)-Farbe_referenz) > Farbe_winkel[Farbe_soll])
 192              		.loc 1 166 0
 193 0130 0360A0E3 		mov	r6, #3
 194 0134 44509FE5 		ldr	r5, .L13+4
 167:Farbe_motor.c ****         {
 168:Farbe_motor.c ****             usleep(1000);
 195              		.loc 1 168 0
 196 0138 FA8FA0E3 		mov	r8, #1000
 166:Farbe_motor.c ****         {
 197              		.loc 1 166 0
 198 013c 010000EA 		b	.L11
 199              	.L12:
 200              		.loc 1 168 0
 201 0140 0800A0E1 		mov	r0, r8
 202 0144 FEFFFFEB 		bl	usleep
 203              	.LVL26:
 204              	.L11:
 166:Farbe_motor.c ****         {
 205              		.loc 1 166 0 discriminator 1
 206 0148 0600A0E1 		mov	r0, r6
 207 014c FEFFFFEB 		bl	cOutputGetCount
 208              	.LVL27:
 209 0150 003095E5 		ldr	r3, [r5]
 210 0154 000063E0 		rsb	r0, r3, r0
 211 0158 000054E1 		cmp	r4, r0
 212 015c F7FFFFBA 		blt	.L12
 213              	.L10:
 169:Farbe_motor.c ****         }
 170:Farbe_motor.c ****     }
 171:Farbe_motor.c ****     cOutputStop(MOTOR_PORT_D,1);
 214              		.loc 1 171 0
 215 0160 0800A0E3 		mov	r0, #8
 216 0164 0110A0E3 		mov	r1, #1
 217 0168 FEFFFFEB 		bl	cOutputStop
 218              	.LVL28:
 172:Farbe_motor.c **** #endif
 173:Farbe_motor.c ****     Farbe_ist=Farbe_soll;
 219              		.loc 1 173 0
 220 016c 0C309FE5 		ldr	r3, .L13+4
 221 0170 047083E5 		str	r7, [r3, #4]
 174:Farbe_motor.c **** #endif
 175:Farbe_motor.c ****     return 0;
 176:Farbe_motor.c **** }
 222              		.loc 1 176 0
 223 0174 0000A0E3 		mov	r0, #0
 224 0178 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 225              	.L14:
 226              		.align	2
 227              	.L13:
 228 017c 00000000 		.word	.LANCHOR1
 229 0180 00000000 		.word	.LANCHOR0
 230              		.cfi_endproc
 231              	.LFE22:
 232              		.fnend
 234              		.align	2
 235              		.global	Farbe_close
 237              	Farbe_close:
 238              		.fnstart
 239              	.LFB23:
 177:Farbe_motor.c **** 
 178:Farbe_motor.c **** 
 179:Farbe_motor.c **** int Farbe_close()
 180:Farbe_motor.c **** {
 240              		.loc 1 180 0
 241              		.cfi_startproc
 242              		@ args = 0, pretend = 0, frame = 0
 243              		@ frame_needed = 0, uses_anonymous_args = 0
 244 0184 08402DE9 		stmfd	sp!, {r3, lr}
 245              		.save {r3, lr}
 246              		.cfi_def_cfa_offset 8
 247              		.cfi_offset 3, -8
 248              		.cfi_offset 14, -4
 181:Farbe_motor.c **** #ifdef __linux__
 182:Farbe_motor.c **** #if 0
 183:Farbe_motor.c ****     char motor_command[4];
 184:Farbe_motor.c ****     
 185:Farbe_motor.c ****     
 186:Farbe_motor.c ****     motor_command[0] = opOUTPUT_STOP;
 187:Farbe_motor.c ****     motor_command[1] = MOTOR_PORT_D;
 188:Farbe_motor.c ****     motor_command[2]=0;
 189:Farbe_motor.c ****     write(motor_file,motor_command,3);
 190:Farbe_motor.c ****     
 191:Farbe_motor.c ****     close(encoder_file);
 192:Farbe_motor.c ****     close(motor_file);
 193:Farbe_motor.c **** #else
 194:Farbe_motor.c ****     cOutputExit();
 249              		.loc 1 194 0
 250 0188 FEFFFFEB 		bl	cOutputExit
 251              	.LVL29:
 195:Farbe_motor.c **** #endif
 196:Farbe_motor.c ****     
 197:Farbe_motor.c **** #endif
 198:Farbe_motor.c ****     return 0;
 199:Farbe_motor.c **** }
 252              		.loc 1 199 0
 253 018c 0000A0E3 		mov	r0, #0
 254 0190 0880BDE8 		ldmfd	sp!, {r3, pc}
 255              		.cfi_endproc
 256              	.LFE23:
 257              		.fnend
 259              		.global	Farbe_winkel
 260              		.global	Farbe_ist
 261              		.global	Farbe_referenz
 262              		.comm	OutputInstance,64,4
 263              		.global	MOTOR_PORT_D
 264              		.global	MOTOR_SPEED_D
 265              		.section	.rodata
 266              		.align	2
 267              	.LANCHOR1 = . + 0
 270              	Farbe_winkel:
 271 0000 04000000 		.word	4
 272 0004 17FDFFFF 		.word	-745
 273 0008 7BFDFFFF 		.word	-645
 274 000c 80FDFFFF 		.word	-640
 275 0010 9EFDFFFF 		.word	-610
 276 0014 B2FDFFFF 		.word	-590
 277 0018 70FEFFFF 		.word	-400
 280              	MOTOR_PORT_D:
 281 001c 08       		.byte	8
 282 001d 000000   		.space	3
 285              	MOTOR_SPEED_D:
 286 0020 1E000000 		.word	30
 287              		.section	.rodata.str1.4,"aMS",%progbits,1
 288              		.align	2
 289              	.LC0:
 290 0000 46617262 		.ascii	"Farbe_referenzPosition angefahren %d\012\015\000"
 290      655F7265 
 290      66657265 
 290      6E7A506F 
 290      73697469 
 291 0027 00       		.bss
 292              		.align	2
 293              	.LANCHOR0 = . + 0
 296              	Farbe_referenz:
 297 0000 00000000 		.space	4
 300              	Farbe_ist:
 301 0004 00000000 		.space	4
 302              		.text
 303              	.Letext0:
 304              		.file 2 "/usr/local/carlson-minot/crosscompilers/arm-none-linux-gnueabi/libc-2014.05-29-sysroot/us
 305              		.file 3 "/usr/local/carlson-minot/crosscompilers/lib/gcc/arm-none-linux-gnueabi/4.8.3/include/stdd
 306              		.file 4 "/usr/local/carlson-minot/crosscompilers/arm-none-linux-gnueabi/libc-2014.05-29-sysroot/us
 307              		.file 5 "lmstypes.h"
 308              		.file 6 "bytecodes.h"
 309              		.file 7 "lms2012.h"
 310              		.file 8 "../lms2012/c_output.h"
 311              		.file 9 "/usr/local/carlson-minot/crosscompilers/arm-none-linux-gnueabi/libc-2014.05-29-sysroot/us
 312              		.file 10 "/usr/local/carlson-minot/crosscompilers/arm-none-linux-gnueabi/libc-2014.05-29-sysroot/u
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Farbe_motor.c
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:16     .text:0000000000000000 $a
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:19     .text:0000000000000000 Farbe_init
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:112    .text:00000000000000a4 $d
                       .ARM.exidx:0000000000000000 $d
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:119    .text:00000000000000b0 $a
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:122    .text:00000000000000b0 Farbe_setpos
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:228    .text:000000000000017c $d
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:234    .text:0000000000000184 $a
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:237    .text:0000000000000184 Farbe_close
                       .ARM.extab:0000000000000000 $d
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:270    .rodata:0000000000000000 Farbe_winkel
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:300    .bss:0000000000000004 Farbe_ist
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:296    .bss:0000000000000000 Farbe_referenz
                            *COM*:0000000000000040 OutputInstance
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:280    .rodata:000000000000001c MOTOR_PORT_D
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:285    .rodata:0000000000000020 MOTOR_SPEED_D
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:266    .rodata:0000000000000000 $d
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:288    .rodata.str1.4:0000000000000000 $d
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccQRt9v4.s:292    .bss:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
cOutputInit
cOutputSetType
cOutputSpeed
cOutputStart
cOutputGetCount
usleep
cOutputStop
printf
__aeabi_unwind_cpp_pr0
cOutputExit
__aeabi_unwind_cpp_pr1
