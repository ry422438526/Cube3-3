   1              		.arch armv5te
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 2
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"Farbe_motor.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	Farbe_init
  19              	Farbe_init:
  20              		.fnstart
  21              	.LFB21:
  22              		.file 1 "Farbe_motor.c"
   1:Farbe_motor.c **** //
   2:Farbe_motor.c **** //  Farbe_motor.c
   3:Farbe_motor.c **** //  Cube3*3
   4:Farbe_motor.c **** //
   5:Farbe_motor.c **** //  Created by 杨春霞 on 12.11.15.
   6:Farbe_motor.c **** //  Copyright © 2015 Chunxia Yang. All rights reserved.
   7:Farbe_motor.c **** //
   8:Farbe_motor.c **** 
   9:Farbe_motor.c **** #include <fcntl.h>
  10:Farbe_motor.c **** #include <stdio.h>
  11:Farbe_motor.c **** #include <sys/mman.h>
  12:Farbe_motor.c **** #ifdef __linux__
  13:Farbe_motor.c **** #include "lms2012.h"
  14:Farbe_motor.c **** #endif
  15:Farbe_motor.c **** #include <unistd.h>
  16:Farbe_motor.c **** #include <stdlib.h>
  17:Farbe_motor.c **** 
  18:Farbe_motor.c **** #include "Farbe_motor.h"
  19:Farbe_motor.c **** 
  20:Farbe_motor.c **** #ifdef __linux__
  21:Farbe_motor.c **** const int MOTOR_SPEED_D=30; //power:0~100
  22:Farbe_motor.c **** const char MOTOR_PORT_D = 0x08; //Schwenkbarer Farbensensor Motor;
  23:Farbe_motor.c **** MOTORDATA *pMotorData;
  24:Farbe_motor.c **** int motor_file;
  25:Farbe_motor.c **** int encoder_file;
  26:Farbe_motor.c **** int Farbe_referenz=0;
  27:Farbe_motor.c **** int Farbe_ist=0;
  28:Farbe_motor.c **** const int Farbe_winkel[]={4,-710,-625,-580,-400};//690------695 veraenderung
  29:Farbe_motor.c **** #endif
  30:Farbe_motor.c **** 
  31:Farbe_motor.c **** int Farbe_init()
  32:Farbe_motor.c **** {
  23              		.loc 1 32 0
  24              		.cfi_startproc
  25              		@ args = 0, pretend = 0, frame = 8
  26              		@ frame_needed = 0, uses_anonymous_args = 0
  27 0000 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
  28              		.save {r4, r5, r6, r7, lr}
  29              		.cfi_def_cfa_offset 20
  30              		.cfi_offset 4, -20
  31              		.cfi_offset 5, -16
  32              		.cfi_offset 6, -12
  33              		.cfi_offset 7, -8
  34              		.cfi_offset 14, -4
  35              		.pad #20
  36 0004 14D04DE2 		sub	sp, sp, #20
  37              		.cfi_def_cfa_offset 40
  33:Farbe_motor.c **** #ifdef __linux__
  34:Farbe_motor.c ****     if ((motor_file = open(PWM_DEVICE_NAME, O_WRONLY))== -1)
  38              		.loc 1 34 0
  39 0008 9C019FE5 		ldr	r0, .L8
  40 000c 0110A0E3 		mov	r1, #1
  41 0010 FEFFFFEB 		bl	open
  42              	.LVL0:
  43 0014 94319FE5 		ldr	r3, .L8+4
  44 0018 000083E5 		str	r0, [r3]
  45 001c 010070E3 		cmn	r0, #1
  46 0020 0300001A 		bne	.L2
  35:Farbe_motor.c ****     {
  36:Farbe_motor.c ****         printf("Failed to open device\n");
  47              		.loc 1 36 0
  48 0024 88019FE5 		ldr	r0, .L8+8
  49 0028 FEFFFFEB 		bl	printf
  50              	.LVL1:
  37:Farbe_motor.c ****         return -1;
  51              		.loc 1 37 0
  52 002c 0000E0E3 		mvn	r0, #0
  53 0030 5B0000EA 		b	.L3
  54              	.L2:
  38:Farbe_motor.c ****     }
  39:Farbe_motor.c ****     
  40:Farbe_motor.c ****     if((encoder_file = open(MOTOR_DEVICE_NAME, O_RDWR | O_SYNC)) == -1)
  55              		.loc 1 40 0
  56 0034 7C019FE5 		ldr	r0, .L8+12
  57 0038 7C119FE5 		ldr	r1, .L8+16
  58 003c FEFFFFEB 		bl	open
  59              	.LVL2:
  60 0040 78319FE5 		ldr	r3, .L8+20
  61 0044 000083E5 		str	r0, [r3]
  62 0048 010070E3 		cmn	r0, #1
  63 004c 5300000A 		beq	.L7
  41:Farbe_motor.c ****         return -1;
  42:Farbe_motor.c ****     pMotorData = (MOTORDATA*)mmap (0, sizeof(MOTORDATA)*vmOUTPUTS, PROT_READ|PROT_WRITE,MAP_FILE|MA
  64              		.loc 1 42 0
  65 0050 00008DE5 		str	r0, [sp]
  66 0054 0000A0E3 		mov	r0, #0
  67 0058 04008DE5 		str	r0, [sp, #4]
  68 005c 3010A0E3 		mov	r1, #48
  69 0060 0320A0E3 		mov	r2, #3
  70 0064 0130A0E3 		mov	r3, #1
  71 0068 FEFFFFEB 		bl	mmap
  72              	.LVL3:
  73 006c 50319FE5 		ldr	r3, .L8+24
  74 0070 000083E5 		str	r0, [r3]
  43:Farbe_motor.c ****     
  44:Farbe_motor.c ****     if (pMotorData == MAP_FAILED)
  75              		.loc 1 44 0
  76 0074 010070E3 		cmn	r0, #1
  77 0078 0300001A 		bne	.L4
  45:Farbe_motor.c ****     {
  46:Farbe_motor.c ****         printf("Map failed\n");
  78              		.loc 1 46 0
  79 007c 44019FE5 		ldr	r0, .L8+28
  80 0080 FEFFFFEB 		bl	printf
  81              	.LVL4:
  47:Farbe_motor.c ****         return -1;
  82              		.loc 1 47 0
  83 0084 0000E0E3 		mvn	r0, #0
  84 0088 450000EA 		b	.L3
  85              	.L4:
  48:Farbe_motor.c ****     }
  49:Farbe_motor.c ****     
  50:Farbe_motor.c ****     char motor_command[4];
  51:Farbe_motor.c ****     motor_command[0]=opOUTPUT_SET_TYPE;
  86              		.loc 1 51 0
  87 008c 5E30E0E3 		mvn	r3, #94
  88 0090 0C30CDE5 		strb	r3, [sp, #12]
  52:Farbe_motor.c ****     motor_command[1]=MOTOR_PORT_D;
  89              		.loc 1 52 0
  90 0094 0840A0E3 		mov	r4, #8
  91 0098 0D40CDE5 		strb	r4, [sp, #13]
  53:Farbe_motor.c ****     motor_command[2]=TYPE_MINITACHO;
  92              		.loc 1 53 0
  93 009c 0E40CDE5 		strb	r4, [sp, #14]
  54:Farbe_motor.c ****     write(motor_file,motor_command,3);// motor_speed Wert geben
  94              		.loc 1 54 0
  95 00a0 08519FE5 		ldr	r5, .L8+4
  96 00a4 000095E5 		ldr	r0, [r5]
  97 00a8 0C108DE2 		add	r1, sp, #12
  98 00ac 0320A0E3 		mov	r2, #3
  99 00b0 FEFFFFEB 		bl	write
 100              	.LVL5:
  55:Farbe_motor.c ****     
  56:Farbe_motor.c ****     motor_command[0]=opOUTPUT_SPEED;
 101              		.loc 1 56 0
 102 00b4 5A30E0E3 		mvn	r3, #90
 103 00b8 0C30CDE5 		strb	r3, [sp, #12]
  57:Farbe_motor.c ****     motor_command[1]=MOTOR_PORT_D;
 104              		.loc 1 57 0
 105 00bc 0D40CDE5 		strb	r4, [sp, #13]
  58:Farbe_motor.c ****     motor_command[2]=MOTOR_SPEED_D;
 106              		.loc 1 58 0
 107 00c0 1E30A0E3 		mov	r3, #30
 108 00c4 0E30CDE5 		strb	r3, [sp, #14]
  59:Farbe_motor.c ****     write(motor_file,motor_command,3);// motor_speed Wert geben
 109              		.loc 1 59 0
 110 00c8 000095E5 		ldr	r0, [r5]
 111 00cc 0C108DE2 		add	r1, sp, #12
 112 00d0 0320A0E3 		mov	r2, #3
 113 00d4 FEFFFFEB 		bl	write
 114              	.LVL6:
  60:Farbe_motor.c ****     
  61:Farbe_motor.c ****     motor_command[0]=opOUTPUT_START;
 115              		.loc 1 61 0
 116 00d8 5930E0E3 		mvn	r3, #89
 117 00dc 0C30CDE5 		strb	r3, [sp, #12]
  62:Farbe_motor.c ****     motor_command[1]=MOTOR_PORT_D;
 118              		.loc 1 62 0
 119 00e0 0D40CDE5 		strb	r4, [sp, #13]
  63:Farbe_motor.c ****     write(motor_file,motor_command,2);// Motor starten
 120              		.loc 1 63 0
 121 00e4 000095E5 		ldr	r0, [r5]
 122 00e8 0C108DE2 		add	r1, sp, #12
 123 00ec 0220A0E3 		mov	r2, #2
 124 00f0 FEFFFFEB 		bl	write
 125              	.LVL7:
  64:Farbe_motor.c ****     
  65:Farbe_motor.c ****     int old_TachoSensor;
  66:Farbe_motor.c ****     old_TachoSensor=pMotorData[3].TachoSensor;
 126              		.loc 1 66 0
 127 00f4 C8409FE5 		ldr	r4, .L8+24
 128 00f8 003094E5 		ldr	r3, [r4]
 129 00fc 2C5093E5 		ldr	r5, [r3, #44]
 130              	.LVL8:
  67:Farbe_motor.c ****     usleep(2*1000000);
 131              		.loc 1 67 0
 132 0100 C4009FE5 		ldr	r0, .L8+32
 133 0104 FEFFFFEB 		bl	usleep
 134              	.LVL9:
  68:Farbe_motor.c ****     while(old_TachoSensor!=pMotorData[3].TachoSensor){
 135              		.loc 1 68 0
 136 0108 002094E5 		ldr	r2, [r4]
 137 010c 2C3092E5 		ldr	r3, [r2, #44]
 138 0110 030055E1 		cmp	r5, r3
 139 0114 0D00000A 		beq	.L5
  69:Farbe_motor.c ****         printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[3].Speed, pMotorData[3].TachoCounts, pMotorD
 140              		.loc 1 69 0
 141 0118 B0709FE5 		ldr	r7, .L8+36
  70:Farbe_motor.c ****         old_TachoSensor=pMotorData[3].TachoSensor;
  71:Farbe_motor.c ****         usleep(1000);
 142              		.loc 1 71 0
 143 011c FA6FA0E3 		mov	r6, #1000
 144              	.LVL10:
 145              	.L6:
  69:Farbe_motor.c ****         printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[3].Speed, pMotorData[3].TachoCounts, pMotorD
 146              		.loc 1 69 0
 147 0120 0700A0E1 		mov	r0, r7
 148 0124 D812D2E1 		ldrsb	r1, [r2, #40]
 149 0128 242092E5 		ldr	r2, [r2, #36]
 150 012c FEFFFFEB 		bl	printf
 151              	.LVL11:
  70:Farbe_motor.c ****         old_TachoSensor=pMotorData[3].TachoSensor;
 152              		.loc 1 70 0
 153 0130 003094E5 		ldr	r3, [r4]
 154 0134 2C5093E5 		ldr	r5, [r3, #44]
 155              	.LVL12:
 156              		.loc 1 71 0
 157 0138 0600A0E1 		mov	r0, r6
 158 013c FEFFFFEB 		bl	usleep
 159              	.LVL13:
  68:Farbe_motor.c ****         printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[3].Speed, pMotorData[3].TachoCounts, pMotorD
 160              		.loc 1 68 0
 161 0140 002094E5 		ldr	r2, [r4]
 162 0144 2C3092E5 		ldr	r3, [r2, #44]
 163 0148 050053E1 		cmp	r3, r5
 164 014c F3FFFF1A 		bne	.L6
 165              	.LVL14:
 166              	.L5:
  72:Farbe_motor.c ****     }
  73:Farbe_motor.c ****     
  74:Farbe_motor.c ****     motor_command[0]=opOUTPUT_STOP;
 167              		.loc 1 74 0
 168 0150 5C30E0E3 		mvn	r3, #92
 169 0154 0C30CDE5 		strb	r3, [sp, #12]
  75:Farbe_motor.c ****     motor_command[1]=MOTOR_PORT_D;
 170              		.loc 1 75 0
 171 0158 0830A0E3 		mov	r3, #8
 172 015c 0D30CDE5 		strb	r3, [sp, #13]
  76:Farbe_motor.c ****     write(motor_file,motor_command,2);  // Motor stoppen
 173              		.loc 1 76 0
 174 0160 48309FE5 		ldr	r3, .L8+4
 175 0164 000093E5 		ldr	r0, [r3]
 176 0168 0C108DE2 		add	r1, sp, #12
 177 016c 0220A0E3 		mov	r2, #2
 178 0170 FEFFFFEB 		bl	write
 179              	.LVL15:
  77:Farbe_motor.c ****     
  78:Farbe_motor.c ****     Farbe_referenz=pMotorData[3].TachoSensor;
 180              		.loc 1 78 0
 181 0174 48309FE5 		ldr	r3, .L8+24
 182 0178 003093E5 		ldr	r3, [r3]
 183 017c 2C1093E5 		ldr	r1, [r3, #44]
 184 0180 4C309FE5 		ldr	r3, .L8+40
 185 0184 001083E5 		str	r1, [r3]
  79:Farbe_motor.c ****     Farbe_ist = 0;
 186              		.loc 1 79 0
 187 0188 0040A0E3 		mov	r4, #0
 188 018c 044083E5 		str	r4, [r3, #4]
  80:Farbe_motor.c ****     printf("Farbe_referenzPosition angefahren %d\n\r",Farbe_referenz);
 189              		.loc 1 80 0
 190 0190 40009FE5 		ldr	r0, .L8+44
 191 0194 FEFFFFEB 		bl	printf
 192              	.LVL16:
  81:Farbe_motor.c ****     
  82:Farbe_motor.c ****     //Farbe_setpos(0);
  83:Farbe_motor.c **** #endif
  84:Farbe_motor.c ****     return 0;
 193              		.loc 1 84 0
 194 0198 0400A0E1 		mov	r0, r4
 195 019c 000000EA 		b	.L3
 196              	.L7:
  41:Farbe_motor.c ****     pMotorData = (MOTORDATA*)mmap (0, sizeof(MOTORDATA)*vmOUTPUTS, PROT_READ|PROT_WRITE,MAP_FILE|MA
 197              		.loc 1 41 0
 198 01a0 0000E0E3 		mvn	r0, #0
 199              	.L3:
  85:Farbe_motor.c **** }
 200              		.loc 1 85 0
 201 01a4 14D08DE2 		add	sp, sp, #20
 202              		@ sp needed
 203 01a8 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 204              	.L9:
 205              		.align	2
 206              	.L8:
 207 01ac 00000000 		.word	.LC0
 208 01b0 00000000 		.word	motor_file
 209 01b4 10000000 		.word	.LC1
 210 01b8 28000000 		.word	.LC2
 211 01bc 02101000 		.word	1052674
 212 01c0 00000000 		.word	encoder_file
 213 01c4 00000000 		.word	pMotorData
 214 01c8 38000000 		.word	.LC3
 215 01cc 80841E00 		.word	2000000
 216 01d0 44000000 		.word	.LC4
 217 01d4 00000000 		.word	.LANCHOR0
 218 01d8 60000000 		.word	.LC5
 219              		.cfi_endproc
 220              	.LFE21:
 221              		.fnend
 223              		.align	2
 224              		.global	Farbe_setpos
 226              	Farbe_setpos:
 227              		.fnstart
 228              	.LFB22:
  86:Farbe_motor.c **** 
  87:Farbe_motor.c **** 
  88:Farbe_motor.c **** int Farbe_setpos(int Farbe_soll)
  89:Farbe_motor.c **** {
 229              		.loc 1 89 0
 230              		.cfi_startproc
 231              		@ args = 0, pretend = 0, frame = 8
 232              		@ frame_needed = 0, uses_anonymous_args = 0
 233              	.LVL17:
 234 01dc F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 235              		.save {r4, r5, r6, r7, r8, lr}
 236              		.cfi_def_cfa_offset 24
 237              		.cfi_offset 4, -24
 238              		.cfi_offset 5, -20
 239              		.cfi_offset 6, -16
 240              		.cfi_offset 7, -12
 241              		.cfi_offset 8, -8
 242              		.cfi_offset 14, -4
 243              		.pad #8
 244 01e0 08D04DE2 		sub	sp, sp, #8
 245              		.cfi_def_cfa_offset 32
 246 01e4 0080A0E1 		mov	r8, r0
  90:Farbe_motor.c **** #ifdef __linux__
  91:Farbe_motor.c ****     char motor_command[4];
  92:Farbe_motor.c ****     motor_command[0]=opOUTPUT_SPEED;
 247              		.loc 1 92 0
 248 01e8 5A30E0E3 		mvn	r3, #90
 249 01ec 0430CDE5 		strb	r3, [sp, #4]
  93:Farbe_motor.c ****     motor_command[1]=MOTOR_PORT_D;
 250              		.loc 1 93 0
 251 01f0 0830A0E3 		mov	r3, #8
 252 01f4 0530CDE5 		strb	r3, [sp, #5]
  94:Farbe_motor.c ****     if(Farbe_winkel[Farbe_ist]<Farbe_winkel[Farbe_soll])
 253              		.loc 1 94 0
 254 01f8 60319FE5 		ldr	r3, .L15
 255 01fc 004193E7 		ldr	r4, [r3, r0, asl #2]
 256 0200 5C219FE5 		ldr	r2, .L15+4
 257 0204 042092E5 		ldr	r2, [r2, #4]
 258 0208 023193E7 		ldr	r3, [r3, r2, asl #2]
 259 020c 040053E1 		cmp	r3, r4
 260 0210 220000AA 		bge	.L11
  95:Farbe_motor.c ****     {
  96:Farbe_motor.c ****         motor_command[2]=MOTOR_SPEED_D;
 261              		.loc 1 96 0
 262 0214 1E30A0E3 		mov	r3, #30
 263 0218 0630CDE5 		strb	r3, [sp, #6]
  97:Farbe_motor.c ****         write(motor_file,motor_command,3);  //motor_speed Wert geben
 264              		.loc 1 97 0
 265 021c 44519FE5 		ldr	r5, .L15+8
 266 0220 000095E5 		ldr	r0, [r5]
 267              	.LVL18:
 268 0224 04108DE2 		add	r1, sp, #4
 269 0228 0320A0E3 		mov	r2, #3
 270 022c FEFFFFEB 		bl	write
 271              	.LVL19:
  98:Farbe_motor.c ****         
  99:Farbe_motor.c ****         motor_command[0]=opOUTPUT_START;
 272              		.loc 1 99 0
 273 0230 5930E0E3 		mvn	r3, #89
 274 0234 0430CDE5 		strb	r3, [sp, #4]
 100:Farbe_motor.c ****         motor_command[1]=MOTOR_PORT_D;
 275              		.loc 1 100 0
 276 0238 0830A0E3 		mov	r3, #8
 277 023c 0530CDE5 		strb	r3, [sp, #5]
 101:Farbe_motor.c ****         write(motor_file,motor_command,2);  //Motor starten
 278              		.loc 1 101 0
 279 0240 000095E5 		ldr	r0, [r5]
 280 0244 04108DE2 		add	r1, sp, #4
 281 0248 0220A0E3 		mov	r2, #2
 282 024c FEFFFFEB 		bl	write
 283              	.LVL20:
 102:Farbe_motor.c ****         
 103:Farbe_motor.c ****         while ((pMotorData[3].TachoSensor-Farbe_referenz) < Farbe_winkel[Farbe_soll])
 284              		.loc 1 103 0
 285 0250 14319FE5 		ldr	r3, .L15+12
 286 0254 003093E5 		ldr	r3, [r3]
 287 0258 2C2093E5 		ldr	r2, [r3, #44]
 288 025c 00319FE5 		ldr	r3, .L15+4
 289 0260 003093E5 		ldr	r3, [r3]
 290 0264 023063E0 		rsb	r3, r3, r2
 291 0268 030054E1 		cmp	r4, r3
 292 026c 2D0000DA 		ble	.L12
 104:Farbe_motor.c ****         {
 105:Farbe_motor.c ****             //printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[3].Speed, pMotorData[3].TachoCounts, p
 106:Farbe_motor.c ****             usleep(1000);
 293              		.loc 1 106 0
 294 0270 FA7FA0E3 		mov	r7, #1000
 103:Farbe_motor.c ****         {
 295              		.loc 1 103 0
 296 0274 F0609FE5 		ldr	r6, .L15+12
 297 0278 E4509FE5 		ldr	r5, .L15+4
 298              	.L13:
 299              		.loc 1 106 0
 300 027c 0700A0E1 		mov	r0, r7
 301 0280 FEFFFFEB 		bl	usleep
 302              	.LVL21:
 103:Farbe_motor.c ****         {
 303              		.loc 1 103 0
 304 0284 003096E5 		ldr	r3, [r6]
 305 0288 2C2093E5 		ldr	r2, [r3, #44]
 306 028c 003095E5 		ldr	r3, [r5]
 307 0290 023063E0 		rsb	r3, r3, r2
 308 0294 030054E1 		cmp	r4, r3
 309 0298 F7FFFFCA 		bgt	.L13
 310 029c 210000EA 		b	.L12
 311              	.LVL22:
 312              	.L11:
 107:Farbe_motor.c ****         }
 108:Farbe_motor.c ****     }
 109:Farbe_motor.c ****     else
 110:Farbe_motor.c ****     {
 111:Farbe_motor.c ****         motor_command[2]=-MOTOR_SPEED_D;
 313              		.loc 1 111 0
 314 02a0 1D30E0E3 		mvn	r3, #29
 315 02a4 0630CDE5 		strb	r3, [sp, #6]
 112:Farbe_motor.c ****         write(motor_file,motor_command,3);  //motor_speed Wert geben
 316              		.loc 1 112 0
 317 02a8 B8509FE5 		ldr	r5, .L15+8
 318 02ac 000095E5 		ldr	r0, [r5]
 319              	.LVL23:
 320 02b0 04108DE2 		add	r1, sp, #4
 321 02b4 0320A0E3 		mov	r2, #3
 322 02b8 FEFFFFEB 		bl	write
 323              	.LVL24:
 113:Farbe_motor.c ****         
 114:Farbe_motor.c ****         motor_command[0]=opOUTPUT_START;
 324              		.loc 1 114 0
 325 02bc 5930E0E3 		mvn	r3, #89
 326 02c0 0430CDE5 		strb	r3, [sp, #4]
 115:Farbe_motor.c ****         motor_command[1]=MOTOR_PORT_D;
 327              		.loc 1 115 0
 328 02c4 0830A0E3 		mov	r3, #8
 329 02c8 0530CDE5 		strb	r3, [sp, #5]
 116:Farbe_motor.c ****         write(motor_file,motor_command,2);  //Motor starten
 330              		.loc 1 116 0
 331 02cc 000095E5 		ldr	r0, [r5]
 332 02d0 04108DE2 		add	r1, sp, #4
 333 02d4 0220A0E3 		mov	r2, #2
 334 02d8 FEFFFFEB 		bl	write
 335              	.LVL25:
 117:Farbe_motor.c ****         
 118:Farbe_motor.c ****         
 119:Farbe_motor.c ****         while ((pMotorData[3].TachoSensor-Farbe_referenz) > Farbe_winkel[Farbe_soll])
 336              		.loc 1 119 0
 337 02dc 88309FE5 		ldr	r3, .L15+12
 338 02e0 003093E5 		ldr	r3, [r3]
 339 02e4 2C2093E5 		ldr	r2, [r3, #44]
 340 02e8 74309FE5 		ldr	r3, .L15+4
 341 02ec 003093E5 		ldr	r3, [r3]
 342 02f0 023063E0 		rsb	r3, r3, r2
 343 02f4 030054E1 		cmp	r4, r3
 344 02f8 0A0000AA 		bge	.L12
 120:Farbe_motor.c ****         {
 121:Farbe_motor.c ****             //printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[3].Speed, pMotorData[3].TachoCounts, p
 122:Farbe_motor.c ****             usleep(1000);
 345              		.loc 1 122 0
 346 02fc FA7FA0E3 		mov	r7, #1000
 119:Farbe_motor.c ****         {
 347              		.loc 1 119 0
 348 0300 64609FE5 		ldr	r6, .L15+12
 349 0304 58509FE5 		ldr	r5, .L15+4
 350              	.L14:
 351              		.loc 1 122 0
 352 0308 0700A0E1 		mov	r0, r7
 353 030c FEFFFFEB 		bl	usleep
 354              	.LVL26:
 119:Farbe_motor.c ****         {
 355              		.loc 1 119 0
 356 0310 003096E5 		ldr	r3, [r6]
 357 0314 2C2093E5 		ldr	r2, [r3, #44]
 358 0318 003095E5 		ldr	r3, [r5]
 359 031c 023063E0 		rsb	r3, r3, r2
 360 0320 030054E1 		cmp	r4, r3
 361 0324 F7FFFFBA 		blt	.L14
 362              	.L12:
 123:Farbe_motor.c ****         }
 124:Farbe_motor.c ****     }
 125:Farbe_motor.c ****     
 126:Farbe_motor.c ****     motor_command[0]=opOUTPUT_STOP;
 363              		.loc 1 126 0
 364 0328 5C30E0E3 		mvn	r3, #92
 365 032c 0430CDE5 		strb	r3, [sp, #4]
 127:Farbe_motor.c ****     motor_command[1]=MOTOR_PORT_D;
 366              		.loc 1 127 0
 367 0330 0830A0E3 		mov	r3, #8
 368 0334 0530CDE5 		strb	r3, [sp, #5]
 128:Farbe_motor.c ****     write(motor_file,motor_command,2); //Motor stopppen
 369              		.loc 1 128 0
 370 0338 28309FE5 		ldr	r3, .L15+8
 371 033c 000093E5 		ldr	r0, [r3]
 372 0340 04108DE2 		add	r1, sp, #4
 373 0344 0220A0E3 		mov	r2, #2
 374 0348 FEFFFFEB 		bl	write
 375              	.LVL27:
 129:Farbe_motor.c ****     
 130:Farbe_motor.c ****     Farbe_ist=Farbe_soll;
 376              		.loc 1 130 0
 377 034c 10309FE5 		ldr	r3, .L15+4
 378 0350 048083E5 		str	r8, [r3, #4]
 131:Farbe_motor.c **** #endif
 132:Farbe_motor.c ****     return 0;
 133:Farbe_motor.c **** }
 379              		.loc 1 133 0
 380 0354 0000A0E3 		mov	r0, #0
 381 0358 08D08DE2 		add	sp, sp, #8
 382              		@ sp needed
 383 035c F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 384              	.LVL28:
 385              	.L16:
 386              		.align	2
 387              	.L15:
 388 0360 00000000 		.word	.LANCHOR1
 389 0364 00000000 		.word	.LANCHOR0
 390 0368 00000000 		.word	motor_file
 391 036c 00000000 		.word	pMotorData
 392              		.cfi_endproc
 393              	.LFE22:
 394              		.fnend
 396              		.align	2
 397              		.global	Farbe_close
 399              	Farbe_close:
 400              		.fnstart
 401              	.LFB23:
 134:Farbe_motor.c **** 
 135:Farbe_motor.c **** 
 136:Farbe_motor.c **** int Farbe_close()
 137:Farbe_motor.c **** {
 402              		.loc 1 137 0
 403              		.cfi_startproc
 404              		@ args = 0, pretend = 0, frame = 8
 405              		@ frame_needed = 0, uses_anonymous_args = 0
 406 0370 30402DE9 		stmfd	sp!, {r4, r5, lr}
 407              		.save {r4, r5, lr}
 408              		.cfi_def_cfa_offset 12
 409              		.cfi_offset 4, -12
 410              		.cfi_offset 5, -8
 411              		.cfi_offset 14, -4
 412              		.pad #12
 413 0374 0CD04DE2 		sub	sp, sp, #12
 414              		.cfi_def_cfa_offset 24
 138:Farbe_motor.c **** #ifdef __linux__
 139:Farbe_motor.c ****     char motor_command[4];
 140:Farbe_motor.c ****     
 141:Farbe_motor.c ****     
 142:Farbe_motor.c ****     motor_command[0] = opOUTPUT_STOP;
 415              		.loc 1 142 0
 416 0378 5C30E0E3 		mvn	r3, #92
 417 037c 0430CDE5 		strb	r3, [sp, #4]
 143:Farbe_motor.c ****     motor_command[1] = MOTOR_PORT_D;
 418              		.loc 1 143 0
 419 0380 0830A0E3 		mov	r3, #8
 420 0384 0530CDE5 		strb	r3, [sp, #5]
 144:Farbe_motor.c ****     motor_command[2]=0;
 421              		.loc 1 144 0
 422 0388 0040A0E3 		mov	r4, #0
 423 038c 0640CDE5 		strb	r4, [sp, #6]
 145:Farbe_motor.c ****     write(motor_file,motor_command,3);
 424              		.loc 1 145 0
 425 0390 2C509FE5 		ldr	r5, .L18
 426 0394 000095E5 		ldr	r0, [r5]
 427 0398 04108DE2 		add	r1, sp, #4
 428 039c 0320A0E3 		mov	r2, #3
 429 03a0 FEFFFFEB 		bl	write
 430              	.LVL29:
 146:Farbe_motor.c ****     
 147:Farbe_motor.c ****     close(encoder_file);
 431              		.loc 1 147 0
 432 03a4 1C309FE5 		ldr	r3, .L18+4
 433 03a8 000093E5 		ldr	r0, [r3]
 434 03ac FEFFFFEB 		bl	close
 435              	.LVL30:
 148:Farbe_motor.c ****     close(motor_file);
 436              		.loc 1 148 0
 437 03b0 000095E5 		ldr	r0, [r5]
 438 03b4 FEFFFFEB 		bl	close
 439              	.LVL31:
 149:Farbe_motor.c **** #endif
 150:Farbe_motor.c ****     return 0;
 151:Farbe_motor.c **** }
 440              		.loc 1 151 0
 441 03b8 0400A0E1 		mov	r0, r4
 442 03bc 0CD08DE2 		add	sp, sp, #12
 443              		@ sp needed
 444 03c0 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 445              	.L19:
 446              		.align	2
 447              	.L18:
 448 03c4 00000000 		.word	motor_file
 449 03c8 00000000 		.word	encoder_file
 450              		.cfi_endproc
 451              	.LFE23:
 452              		.fnend
 454              		.global	Farbe_winkel
 455              		.global	Farbe_ist
 456              		.global	Farbe_referenz
 457              		.comm	encoder_file,4,4
 458              		.comm	motor_file,4,4
 459              		.comm	pMotorData,4,4
 460              		.global	MOTOR_PORT_D
 461              		.global	MOTOR_SPEED_D
 462              		.section	.rodata
 463              		.align	2
 464              	.LANCHOR1 = . + 0
 467              	Farbe_winkel:
 468 0000 04000000 		.word	4
 469 0004 3AFDFFFF 		.word	-710
 470 0008 8FFDFFFF 		.word	-625
 471 000c BCFDFFFF 		.word	-580
 472 0010 70FEFFFF 		.word	-400
 475              	MOTOR_PORT_D:
 476 0014 08       		.byte	8
 477 0015 000000   		.space	3
 480              	MOTOR_SPEED_D:
 481 0018 1E000000 		.word	30
 482              		.section	.rodata.str1.4,"aMS",%progbits,1
 483              		.align	2
 484              	.LC0:
 485 0000 2F646576 		.ascii	"/dev/lms_pwm\000"
 485      2F6C6D73 
 485      5F70776D 
 485      00
 486 000d 000000   		.space	3
 487              	.LC1:
 488 0010 4661696C 		.ascii	"Failed to open device\012\000"
 488      65642074 
 488      6F206F70 
 488      656E2064 
 488      65766963 
 489 0027 00       		.space	1
 490              	.LC2:
 491 0028 2F646576 		.ascii	"/dev/lms_motor\000"
 491      2F6C6D73 
 491      5F6D6F74 
 491      6F7200
 492 0037 00       		.space	1
 493              	.LC3:
 494 0038 4D617020 		.ascii	"Map failed\012\000"
 494      6661696C 
 494      65640A00 
 495              	.LC4:
 496 0044 5370642F 		.ascii	"Spd/Cnt/Snr: A=%d/%d/%d\012\000"
 496      436E742F 
 496      536E723A 
 496      20413D25 
 496      642F2564 
 497 005d 000000   		.space	3
 498              	.LC5:
 499 0060 46617262 		.ascii	"Farbe_referenzPosition angefahren %d\012\015\000"
 499      655F7265 
 499      66657265 
 499      6E7A506F 
 499      73697469 
 500 0087 00       		.bss
 501              		.align	2
 502              	.LANCHOR0 = . + 0
 505              	Farbe_referenz:
 506 0000 00000000 		.space	4
 509              	Farbe_ist:
 510 0004 00000000 		.space	4
 511              		.text
 512              	.Letext0:
 513              		.file 2 "/usr/local/carlson-minot/crosscompilers/arm-none-linux-gnueabi/libc-2014.05-29-sysroot/us
 514              		.file 3 "/usr/local/carlson-minot/crosscompilers/lib/gcc/arm-none-linux-gnueabi/4.8.3/include/stdd
 515              		.file 4 "/usr/local/carlson-minot/crosscompilers/arm-none-linux-gnueabi/libc-2014.05-29-sysroot/us
 516              		.file 5 "/usr/local/carlson-minot/crosscompilers/arm-none-linux-gnueabi/libc-2014.05-29-sysroot/us
 517              		.file 6 "lmstypes.h"
 518              		.file 7 "bytecodes.h"
 519              		.file 8 "lms2012.h"
 520              		.file 9 "/usr/local/carlson-minot/crosscompilers/arm-none-linux-gnueabi/libc-2014.05-29-sysroot/us
 521              		.file 10 "/usr/local/carlson-minot/crosscompilers/arm-none-linux-gnueabi/libc-2014.05-29-sysroot/u
 522              		.file 11 "/usr/local/carlson-minot/crosscompilers/arm-none-linux-gnueabi/libc-2014.05-29-sysroot/u
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Farbe_motor.c
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:16     .text:0000000000000000 $a
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:19     .text:0000000000000000 Farbe_init
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:207    .text:00000000000001ac $d
                            *COM*:0000000000000004 motor_file
                            *COM*:0000000000000004 encoder_file
                            *COM*:0000000000000004 pMotorData
                       .ARM.exidx:0000000000000000 $d
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:223    .text:00000000000001dc $a
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:226    .text:00000000000001dc Farbe_setpos
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:388    .text:0000000000000360 $d
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:396    .text:0000000000000370 $a
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:399    .text:0000000000000370 Farbe_close
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:448    .text:00000000000003c4 $d
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:467    .rodata:0000000000000000 Farbe_winkel
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:509    .bss:0000000000000004 Farbe_ist
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:505    .bss:0000000000000000 Farbe_referenz
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:475    .rodata:0000000000000014 MOTOR_PORT_D
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:480    .rodata:0000000000000018 MOTOR_SPEED_D
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:463    .rodata:0000000000000000 $d
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:483    .rodata.str1.4:0000000000000000 $d
/var/folders/23/5yg9vnhn5dd7xxkqmvdyw4ww0000gn/T//ccivXZdc.s:501    .bss:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
open
printf
mmap
write
usleep
__aeabi_unwind_cpp_pr0
close
