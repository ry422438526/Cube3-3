   1              		.arch armv5te
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 2
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"Dreh_motor.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	DrehTel_setpos
  19              	DrehTel_setpos:
  20              		.fnstart
  21              	.LFB12:
  22              		.file 1 "Dreh_motor.c"
   1:Dreh_motor.c  **** //
   2:Dreh_motor.c  **** //  Dreh_motor.c
   3:Dreh_motor.c  **** //  Cube3*3
   4:Dreh_motor.c  **** //
   5:Dreh_motor.c  **** //  Created by 杨春霞 on 12.11.15.
   6:Dreh_motor.c  **** //  Copyright © 2015 Chunxia Yang. All rights reserved.
   7:Dreh_motor.c  **** //
   8:Dreh_motor.c  **** 
   9:Dreh_motor.c  **** #include <fcntl.h>
  10:Dreh_motor.c  **** #include <stdio.h>
  11:Dreh_motor.c  **** #include <sys/mman.h>
  12:Dreh_motor.c  **** #ifdef __linux__
  13:Dreh_motor.c  **** #include "lms2012.h"
  14:Dreh_motor.c  **** #include "../lms2012/c_output.h"
  15:Dreh_motor.c  **** #include <unistd.h>
  16:Dreh_motor.c  **** #endif
  17:Dreh_motor.c  **** #include "Dreh_motor.h"
  18:Dreh_motor.c  **** 
  19:Dreh_motor.c  **** #ifdef __linux__
  20:Dreh_motor.c  **** const int MOTOR_SPEED_B=35;
  21:Dreh_motor.c  **** const char MOTOR_PORT_B=0x02; //Drehteller Motor;
  22:Dreh_motor.c  **** #if 0
  23:Dreh_motor.c  **** MOTORDATA *pMotorData;
  24:Dreh_motor.c  **** int motor_file;
  25:Dreh_motor.c  **** int encoder_file;
  26:Dreh_motor.c  **** #else
  27:Dreh_motor.c  **** OUTPUT_GLOBALS OutputInstance;
  28:Dreh_motor.c  **** #endif
  29:Dreh_motor.c  **** int Tel_ist=0;
  30:Dreh_motor.c  **** int Tel_referenz=0;
  31:Dreh_motor.c  **** const int dreh_winkel[]={0*90*3,1*90*3,-1*90*3,2*90*3,-2*90*3};//274
  32:Dreh_motor.c  **** const int dreh_Korr_Winkel=10;  //Korrigieren Winkel
  33:Dreh_motor.c  **** #endif
  34:Dreh_motor.c  **** 
  35:Dreh_motor.c  **** 
  36:Dreh_motor.c  **** int DrehTel_init()
  37:Dreh_motor.c  **** {
  38:Dreh_motor.c  **** // /Users/yangchunxia/Documents/Cube3*3/lms2012/c_output.h
  39:Dreh_motor.c  **** #ifdef __linux__
  40:Dreh_motor.c  **** #if 0
  41:Dreh_motor.c  ****     if ((motor_file = open(PWM_DEVICE_NAME, O_WRONLY))== -1)
  42:Dreh_motor.c  ****     {
  43:Dreh_motor.c  ****         printf("Failed to open device\n");
  44:Dreh_motor.c  ****         return -1;
  45:Dreh_motor.c  ****     }
  46:Dreh_motor.c  ****     if((encoder_file = open(MOTOR_DEVICE_NAME, O_RDWR | O_SYNC)) == -1)
  47:Dreh_motor.c  ****         return -1;
  48:Dreh_motor.c  ****     pMotorData = (MOTORDATA*)mmap (0, sizeof(MOTORDATA)*vmOUTPUTS, PROT_READ|PROT_WRITE,MAP_FILE|MA
  49:Dreh_motor.c  ****     if (pMotorData == MAP_FAILED)
  50:Dreh_motor.c  ****     {
  51:Dreh_motor.c  ****         printf("Map failed\n");
  52:Dreh_motor.c  ****         return -1;
  53:Dreh_motor.c  ****     }
  54:Dreh_motor.c  **** #else
  55:Dreh_motor.c  ****     cOutputInit();
  56:Dreh_motor.c  **** #endif
  57:Dreh_motor.c  ****     Tel_referenz=cOutputGetCount(1);
  58:Dreh_motor.c  ****     printf("DrehTeller_referenz Position angefahren: %d\n\r",Tel_referenz);
  59:Dreh_motor.c  ****     Tel_ist=0;
  60:Dreh_motor.c  ****     DrehTel_setpos(0);
  61:Dreh_motor.c  **** #endif
  62:Dreh_motor.c  ****     return 0;
  63:Dreh_motor.c  **** }
  64:Dreh_motor.c  **** 
  65:Dreh_motor.c  **** 
  66:Dreh_motor.c  **** int DrehTel_setpos(int Tel_soll)
  67:Dreh_motor.c  **** {
  23              		.loc 1 67 0
  24              		.cfi_startproc
  25              		@ args = 0, pretend = 0, frame = 0
  26              		@ frame_needed = 0, uses_anonymous_args = 0
  27              	.LVL0:
  28 0000 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
  29              		.save {r4, r5, r6, r7, r8, lr}
  30              		.cfi_def_cfa_offset 24
  31              		.cfi_offset 4, -24
  32              		.cfi_offset 5, -20
  33              		.cfi_offset 6, -16
  34              		.cfi_offset 7, -12
  35              		.cfi_offset 8, -8
  36              		.cfi_offset 14, -4
  37 0004 0060A0E1 		mov	r6, r0
  68:Dreh_motor.c  **** #ifdef __linux__
  69:Dreh_motor.c  **** #if 0
  70:Dreh_motor.c  ****     char motor_command[4];
  71:Dreh_motor.c  ****     
  72:Dreh_motor.c  ****     motor_command[0]=opOUTPUT_SPEED;
  73:Dreh_motor.c  ****     motor_command[1]=MOTOR_PORT_B;
  74:Dreh_motor.c  ****     if (dreh_winkel[Tel_soll]<=0)
  75:Dreh_motor.c  ****     {
  76:Dreh_motor.c  ****         motor_command[2]=-MOTOR_SPEED_B;
  77:Dreh_motor.c  ****         write(motor_file,motor_command,3);    //Motor_speed Wert geben
  78:Dreh_motor.c  ****         
  79:Dreh_motor.c  ****         motor_command[0]=opOUTPUT_START;
  80:Dreh_motor.c  ****         motor_command[1]=MOTOR_PORT_B;
  81:Dreh_motor.c  ****         write(motor_file,motor_command,2);    //Motor  srarten
  82:Dreh_motor.c  ****         while((pMotorData[1].TachoSensor-Tel_referenz) >= (dreh_winkel[Tel_soll]-20))  //40
  83:Dreh_motor.c  ****         {
  84:Dreh_motor.c  ****             // printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[1].Speed, pMotorData[1].TachoCounts, 
  85:Dreh_motor.c  ****             usleep(1000);
  86:Dreh_motor.c  ****         }
  87:Dreh_motor.c  ****         motor_command[0]=opOUTPUT_STOP;
  88:Dreh_motor.c  ****         motor_command[1]=MOTOR_PORT_B;
  89:Dreh_motor.c  ****         motor_command[2]=1;
  90:Dreh_motor.c  ****         write(motor_file,motor_command,3);
  91:Dreh_motor.c  ****         
  92:Dreh_motor.c  ****         Tel_referenz=pMotorData[1].TachoSensor;
  93:Dreh_motor.c  ****         
  94:Dreh_motor.c  ****         motor_command[0]=opOUTPUT_SPEED;
  95:Dreh_motor.c  ****         motor_command[1]=MOTOR_PORT_B;
  96:Dreh_motor.c  ****         motor_command[2]=MOTOR_SPEED_B;
  97:Dreh_motor.c  ****         write(motor_file,motor_command,3);
  98:Dreh_motor.c  ****         
  99:Dreh_motor.c  ****         motor_command[0]=opOUTPUT_START;
 100:Dreh_motor.c  ****         motor_command[1]=MOTOR_PORT_B;
 101:Dreh_motor.c  ****         write(motor_file,motor_command,2);
 102:Dreh_motor.c  ****         
 103:Dreh_motor.c  ****         while(pMotorData[1].TachoSensor-Tel_referenz<20)
 104:Dreh_motor.c  ****         {
 105:Dreh_motor.c  ****             // printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[1].Speed, pMotorData[1].TachoCounts, 
 106:Dreh_motor.c  ****             usleep(100);
 107:Dreh_motor.c  ****         }
 108:Dreh_motor.c  ****         
 109:Dreh_motor.c  ****     }
 110:Dreh_motor.c  ****     else
 111:Dreh_motor.c  ****         
 112:Dreh_motor.c  ****     {
 113:Dreh_motor.c  ****         motor_command[2]=MOTOR_SPEED_B;
 114:Dreh_motor.c  ****         write(motor_file,motor_command,3);    //Motor_speed Wert geben
 115:Dreh_motor.c  ****         
 116:Dreh_motor.c  ****         motor_command[0]=opOUTPUT_START;
 117:Dreh_motor.c  ****         motor_command[1]=MOTOR_PORT_B;
 118:Dreh_motor.c  ****         write(motor_file,motor_command,2);    //Motor  srarten
 119:Dreh_motor.c  ****         
 120:Dreh_motor.c  ****         while((pMotorData[1].TachoSensor-Tel_referenz) < (dreh_winkel[Tel_soll]+20))
 121:Dreh_motor.c  ****         {
 122:Dreh_motor.c  ****             //printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[1].Speed, pMotorData[1].TachoCounts, p
 123:Dreh_motor.c  ****             usleep(1000);
 124:Dreh_motor.c  ****         }
 125:Dreh_motor.c  ****         
 126:Dreh_motor.c  ****         motor_command[0]=opOUTPUT_STOP;
 127:Dreh_motor.c  ****         motor_command[1]=MOTOR_PORT_B;
 128:Dreh_motor.c  ****         motor_command[2]=1;
 129:Dreh_motor.c  ****         write(motor_file,motor_command,3);
 130:Dreh_motor.c  ****         
 131:Dreh_motor.c  ****         Tel_referenz=pMotorData[1].TachoSensor;
 132:Dreh_motor.c  ****         
 133:Dreh_motor.c  ****         motor_command[0]=opOUTPUT_SPEED;
 134:Dreh_motor.c  ****         motor_command[1]=MOTOR_PORT_B;
 135:Dreh_motor.c  ****         motor_command[2]=-MOTOR_SPEED_B;
 136:Dreh_motor.c  ****         write(motor_file,motor_command,3);
 137:Dreh_motor.c  ****         
 138:Dreh_motor.c  ****         motor_command[0]=opOUTPUT_START;
 139:Dreh_motor.c  ****         motor_command[1]=MOTOR_PORT_B;
 140:Dreh_motor.c  ****         write(motor_file,motor_command,2);
 141:Dreh_motor.c  ****         
 142:Dreh_motor.c  ****         while(pMotorData[1].TachoSensor-Tel_referenz>-20)
 143:Dreh_motor.c  ****         {
 144:Dreh_motor.c  ****             /*printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[1].Speed, pMotorData[1].TachoCounts, p
 145:Dreh_motor.c  ****             usleep(100);
 146:Dreh_motor.c  ****         }
 147:Dreh_motor.c  ****         
 148:Dreh_motor.c  ****         
 149:Dreh_motor.c  ****     }
 150:Dreh_motor.c  ****     motor_command[0]=opOUTPUT_STOP;
 151:Dreh_motor.c  ****     motor_command[1]=MOTOR_PORT_B;
 152:Dreh_motor.c  ****     motor_command[2]=1;
 153:Dreh_motor.c  ****     write(motor_file,motor_command,3);  //Motor stoppen
 154:Dreh_motor.c  **** #else
 155:Dreh_motor.c  ****     /*if(dreh_winkel[Tel_soll]<0)
 156:Dreh_motor.c  ****      {
 157:Dreh_motor.c  ****         switch (Tel_soll) {
 158:Dreh_motor.c  ****             case 2:
 159:Dreh_motor.c  ****                 cOutputStepSpeed(MOTOR_PORT_B, -MOTOR_SPEED_B, 10*3, 70*3, 10*3, 1);
 160:Dreh_motor.c  ****                 break;
 161:Dreh_motor.c  ****             case 4:
 162:Dreh_motor.c  ****                 cOutputStepSpeed(MOTOR_PORT_B, -MOTOR_SPEED_B, 10*3*2, 70*3*2, 10*3*2, 1);
 163:Dreh_motor.c  ****                 break;
 164:Dreh_motor.c  ****             default:
 165:Dreh_motor.c  ****                 break;
 166:Dreh_motor.c  ****         }
 167:Dreh_motor.c  ****         //cOutputStepSpeed(MOTOR_PORT_B, -MOTOR_SPEED_B, 10*3, 80*3, 10*3, 1);
 168:Dreh_motor.c  ****         while((OutputInstance.MotorData[1].TachoSensor-Tel_referenz) >= (dreh_winkel[Tel_soll]-30))
 169:Dreh_motor.c  ****         {
 170:Dreh_motor.c  ****             usleep(1000);
 171:Dreh_motor.c  ****         }
 172:Dreh_motor.c  ****         Tel_referenz=OutputInstance.MotorData[1].TachoSensor;
 173:Dreh_motor.c  ****         cOutputStepSpeed(MOTOR_PORT_B,  MOTOR_SPEED_B, -(1*3),-(9*3),-(10*3),1);
 174:Dreh_motor.c  ****         while(OutputInstance.MotorData[1].TachoSensor-Tel_referenz<30)
 175:Dreh_motor.c  ****         {
 176:Dreh_motor.c  ****             usleep(100);
 177:Dreh_motor.c  ****         }
 178:Dreh_motor.c  ****     }else{
 179:Dreh_motor.c  ****         
 180:Dreh_motor.c  ****         switch (Tel_soll) {
 181:Dreh_motor.c  ****             case 1:
 182:Dreh_motor.c  ****                 cOutputStepSpeed(MOTOR_PORT_B, MOTOR_SPEED_B, 10*3, 70*3, 10*3, 1);
 183:Dreh_motor.c  ****                 break;
 184:Dreh_motor.c  ****             case 3:
 185:Dreh_motor.c  ****                 cOutputStepSpeed(MOTOR_PORT_B, MOTOR_SPEED_B, 10*3*2, 70*3*2, 10*3*2, 1);
 186:Dreh_motor.c  ****                 break;
 187:Dreh_motor.c  ****             default:
 188:Dreh_motor.c  ****             break;}
 189:Dreh_motor.c  ****         //cOutputStepSpeed(MOTOR_PORT_B,  MOTOR_SPEED_B, 10*3, 80*3, 10*3, 1);
 190:Dreh_motor.c  ****         while((OutputInstance.MotorData[1].TachoSensor-Tel_referenz) < (dreh_winkel[Tel_soll]+40))
 191:Dreh_motor.c  ****         {
 192:Dreh_motor.c  ****             usleep(1000);
 193:Dreh_motor.c  ****         }
 194:Dreh_motor.c  ****         Tel_referenz=OutputInstance.MotorData[1].TachoSensor;
 195:Dreh_motor.c  ****         cOutputStepSpeed(MOTOR_PORT_B, -MOTOR_SPEED_B, -(1*3),-(9*3),-(10*3),1);
 196:Dreh_motor.c  ****         while(OutputInstance.MotorData[1].TachoSensor-Tel_referenz>-30)
 197:Dreh_motor.c  ****         {
 198:Dreh_motor.c  ****             usleep(100);
 199:Dreh_motor.c  ****         }
 200:Dreh_motor.c  ****      }*/
 201:Dreh_motor.c  ****     Tel_referenz=cOutputGetCount(1);
  38              		.loc 1 201 0
  39 0008 0100A0E3 		mov	r0, #1
  40              	.LVL1:
  41 000c FEFFFFEB 		bl	cOutputGetCount
  42              	.LVL2:
  43 0010 BC319FE5 		ldr	r3, .L12
  44 0014 000083E5 		str	r0, [r3]
 202:Dreh_motor.c  ****     if (dreh_winkel[Tel_soll]<=0)
  45              		.loc 1 202 0
  46 0018 B8319FE5 		ldr	r3, .L12+4
  47 001c 064193E7 		ldr	r4, [r3, r6, asl #2]
  48 0020 000054E3 		cmp	r4, #0
  49 0024 2C0000CA 		bgt	.L2
 203:Dreh_motor.c  ****     {
 204:Dreh_motor.c  ****         cOutputSpeed(MOTOR_PORT_B,-MOTOR_SPEED_B);
  50              		.loc 1 204 0
  51 0028 0200A0E3 		mov	r0, #2
  52 002c 2210E0E3 		mvn	r1, #34
  53 0030 FEFFFFEB 		bl	cOutputSpeed
  54              	.LVL3:
 205:Dreh_motor.c  ****         cOutputStart(MOTOR_PORT_B);
  55              		.loc 1 205 0
  56 0034 0200A0E3 		mov	r0, #2
  57 0038 FEFFFFEB 		bl	cOutputStart
  58              	.LVL4:
 206:Dreh_motor.c  ****         while((cOutputGetCount(1)-Tel_referenz) >= (dreh_winkel[Tel_soll]-20))
  59              		.loc 1 206 0
  60 003c 0170A0E3 		mov	r7, #1
  61 0040 8C519FE5 		ldr	r5, .L12
  62 0044 144044E2 		sub	r4, r4, #20
 207:Dreh_motor.c  ****         {
 208:Dreh_motor.c  ****             // printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[1].Speed, pMotorData[1].TachoCounts, 
 209:Dreh_motor.c  ****             usleep(1000);
  63              		.loc 1 209 0
  64 0048 FA8FA0E3 		mov	r8, #1000
 206:Dreh_motor.c  ****         while((cOutputGetCount(1)-Tel_referenz) >= (dreh_winkel[Tel_soll]-20))
  65              		.loc 1 206 0
  66 004c 010000EA 		b	.L3
  67              	.L4:
  68              		.loc 1 209 0
  69 0050 0800A0E1 		mov	r0, r8
  70 0054 FEFFFFEB 		bl	usleep
  71              	.LVL5:
  72              	.L3:
 206:Dreh_motor.c  ****         while((cOutputGetCount(1)-Tel_referenz) >= (dreh_winkel[Tel_soll]-20))
  73              		.loc 1 206 0 discriminator 1
  74 0058 0700A0E1 		mov	r0, r7
  75 005c FEFFFFEB 		bl	cOutputGetCount
  76              	.LVL6:
  77 0060 003095E5 		ldr	r3, [r5]
  78 0064 000063E0 		rsb	r0, r3, r0
  79 0068 040050E1 		cmp	r0, r4
  80 006c F7FFFFAA 		bge	.L4
 210:Dreh_motor.c  ****         }
 211:Dreh_motor.c  ****         cOutputStop(MOTOR_PORT_B,1);
  81              		.loc 1 211 0
  82 0070 0200A0E3 		mov	r0, #2
  83 0074 0110A0E3 		mov	r1, #1
  84 0078 FEFFFFEB 		bl	cOutputStop
  85              	.LVL7:
 212:Dreh_motor.c  ****         
 213:Dreh_motor.c  ****         Tel_referenz=cOutputGetCount(1);
  86              		.loc 1 213 0
  87 007c 0100A0E3 		mov	r0, #1
  88 0080 FEFFFFEB 		bl	cOutputGetCount
  89              	.LVL8:
  90 0084 48319FE5 		ldr	r3, .L12
  91 0088 000083E5 		str	r0, [r3]
 214:Dreh_motor.c  ****         
 215:Dreh_motor.c  ****         cOutputSpeed(MOTOR_PORT_B,MOTOR_SPEED_B);
  92              		.loc 1 215 0
  93 008c 0200A0E3 		mov	r0, #2
  94 0090 2310A0E3 		mov	r1, #35
  95 0094 FEFFFFEB 		bl	cOutputSpeed
  96              	.LVL9:
 216:Dreh_motor.c  ****         cOutputStart(MOTOR_PORT_B);
  97              		.loc 1 216 0
  98 0098 0200A0E3 		mov	r0, #2
  99 009c FEFFFFEB 		bl	cOutputStart
 100              	.LVL10:
 217:Dreh_motor.c  ****         usleep(10000);
 101              		.loc 1 217 0
 102 00a0 34019FE5 		ldr	r0, .L12+8
 103 00a4 FEFFFFEB 		bl	usleep
 104              	.LVL11:
 218:Dreh_motor.c  ****         while(cOutputGetCount(1)-Tel_referenz<20)
 105              		.loc 1 218 0
 106 00a8 0150A0E3 		mov	r5, #1
 107 00ac 20419FE5 		ldr	r4, .L12
 219:Dreh_motor.c  ****         {
 220:Dreh_motor.c  ****             // printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[1].Speed, pMotorData[1].TachoCounts, 
 221:Dreh_motor.c  ****             usleep(100);
 108              		.loc 1 221 0
 109 00b0 6470A0E3 		mov	r7, #100
 218:Dreh_motor.c  ****         while(cOutputGetCount(1)-Tel_referenz<20)
 110              		.loc 1 218 0
 111 00b4 010000EA 		b	.L5
 112              	.L6:
 113              		.loc 1 221 0
 114 00b8 0700A0E1 		mov	r0, r7
 115 00bc FEFFFFEB 		bl	usleep
 116              	.LVL12:
 117              	.L5:
 218:Dreh_motor.c  ****         while(cOutputGetCount(1)-Tel_referenz<20)
 118              		.loc 1 218 0 discriminator 1
 119 00c0 0500A0E1 		mov	r0, r5
 120 00c4 FEFFFFEB 		bl	cOutputGetCount
 121              	.LVL13:
 122 00c8 003094E5 		ldr	r3, [r4]
 123 00cc 000063E0 		rsb	r0, r3, r0
 124 00d0 130050E3 		cmp	r0, #19
 125 00d4 F7FFFFDA 		ble	.L6
 126 00d8 2B0000EA 		b	.L7
 127              	.L2:
 222:Dreh_motor.c  ****         }
 223:Dreh_motor.c  ****         
 224:Dreh_motor.c  ****     }
 225:Dreh_motor.c  ****     else
 226:Dreh_motor.c  ****         
 227:Dreh_motor.c  ****     {
 228:Dreh_motor.c  ****         cOutputSpeed(MOTOR_PORT_B,MOTOR_SPEED_B);
 128              		.loc 1 228 0
 129 00dc 0200A0E3 		mov	r0, #2
 130 00e0 2310A0E3 		mov	r1, #35
 131 00e4 FEFFFFEB 		bl	cOutputSpeed
 132              	.LVL14:
 229:Dreh_motor.c  ****         cOutputStart(MOTOR_PORT_B);
 133              		.loc 1 229 0
 134 00e8 0200A0E3 		mov	r0, #2
 135 00ec FEFFFFEB 		bl	cOutputStart
 136              	.LVL15:
 230:Dreh_motor.c  ****         
 231:Dreh_motor.c  ****         while((cOutputGetCount(1)-Tel_referenz) < (dreh_winkel[Tel_soll]+20))
 137              		.loc 1 231 0
 138 00f0 0170A0E3 		mov	r7, #1
 139 00f4 D8509FE5 		ldr	r5, .L12
 140 00f8 144084E2 		add	r4, r4, #20
 232:Dreh_motor.c  ****         {
 233:Dreh_motor.c  ****             //printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[1].Speed, pMotorData[1].TachoCounts, p
 234:Dreh_motor.c  ****             usleep(1000);
 141              		.loc 1 234 0
 142 00fc FA8FA0E3 		mov	r8, #1000
 231:Dreh_motor.c  ****         {
 143              		.loc 1 231 0
 144 0100 010000EA 		b	.L8
 145              	.L9:
 146              		.loc 1 234 0
 147 0104 0800A0E1 		mov	r0, r8
 148 0108 FEFFFFEB 		bl	usleep
 149              	.LVL16:
 150              	.L8:
 231:Dreh_motor.c  ****         {
 151              		.loc 1 231 0 discriminator 1
 152 010c 0700A0E1 		mov	r0, r7
 153 0110 FEFFFFEB 		bl	cOutputGetCount
 154              	.LVL17:
 155 0114 003095E5 		ldr	r3, [r5]
 156 0118 000063E0 		rsb	r0, r3, r0
 157 011c 040050E1 		cmp	r0, r4
 158 0120 F7FFFFBA 		blt	.L9
 235:Dreh_motor.c  ****         }
 236:Dreh_motor.c  ****         
 237:Dreh_motor.c  ****         cOutputStop(MOTOR_PORT_B,1);
 159              		.loc 1 237 0
 160 0124 0200A0E3 		mov	r0, #2
 161 0128 0110A0E3 		mov	r1, #1
 162 012c FEFFFFEB 		bl	cOutputStop
 163              	.LVL18:
 238:Dreh_motor.c  ****         
 239:Dreh_motor.c  ****         Tel_referenz=cOutputGetCount(1);
 164              		.loc 1 239 0
 165 0130 0100A0E3 		mov	r0, #1
 166 0134 FEFFFFEB 		bl	cOutputGetCount
 167              	.LVL19:
 168 0138 94309FE5 		ldr	r3, .L12
 169 013c 000083E5 		str	r0, [r3]
 240:Dreh_motor.c  ****         
 241:Dreh_motor.c  ****         cOutputSpeed(MOTOR_PORT_B,-MOTOR_SPEED_B);
 170              		.loc 1 241 0
 171 0140 0200A0E3 		mov	r0, #2
 172 0144 2210E0E3 		mvn	r1, #34
 173 0148 FEFFFFEB 		bl	cOutputSpeed
 174              	.LVL20:
 242:Dreh_motor.c  ****         cOutputStart(MOTOR_PORT_B);
 175              		.loc 1 242 0
 176 014c 0200A0E3 		mov	r0, #2
 177 0150 FEFFFFEB 		bl	cOutputStart
 178              	.LVL21:
 243:Dreh_motor.c  ****         usleep(10000);
 179              		.loc 1 243 0
 180 0154 80009FE5 		ldr	r0, .L12+8
 181 0158 FEFFFFEB 		bl	usleep
 182              	.LVL22:
 244:Dreh_motor.c  ****         while(cOutputGetCount(1)-Tel_referenz>-20)
 183              		.loc 1 244 0
 184 015c 0150A0E3 		mov	r5, #1
 185 0160 6C409FE5 		ldr	r4, .L12
 245:Dreh_motor.c  ****         {
 246:Dreh_motor.c  ****             /*printf("Spd/Cnt/Snr: A=%d/%d/%d\n", pMotorData[1].Speed, pMotorData[1].TachoCounts, p
 247:Dreh_motor.c  ****             usleep(100);
 186              		.loc 1 247 0
 187 0164 6470A0E3 		mov	r7, #100
 244:Dreh_motor.c  ****         while(cOutputGetCount(1)-Tel_referenz>-20)
 188              		.loc 1 244 0
 189 0168 010000EA 		b	.L10
 190              	.L11:
 191              		.loc 1 247 0
 192 016c 0700A0E1 		mov	r0, r7
 193 0170 FEFFFFEB 		bl	usleep
 194              	.LVL23:
 195              	.L10:
 244:Dreh_motor.c  ****         while(cOutputGetCount(1)-Tel_referenz>-20)
 196              		.loc 1 244 0 discriminator 1
 197 0174 0500A0E1 		mov	r0, r5
 198 0178 FEFFFFEB 		bl	cOutputGetCount
 199              	.LVL24:
 200 017c 003094E5 		ldr	r3, [r4]
 201 0180 000063E0 		rsb	r0, r3, r0
 202 0184 130070E3 		cmn	r0, #19
 203 0188 F7FFFFAA 		bge	.L11
 204              	.L7:
 248:Dreh_motor.c  ****         }
 249:Dreh_motor.c  ****         
 250:Dreh_motor.c  ****     }
 251:Dreh_motor.c  ****     cOutputStop(MOTOR_PORT_B,1);
 205              		.loc 1 251 0
 206 018c 0200A0E3 		mov	r0, #2
 207 0190 0110A0E3 		mov	r1, #1
 208 0194 FEFFFFEB 		bl	cOutputStop
 209              	.LVL25:
 252:Dreh_motor.c  **** #endif
 253:Dreh_motor.c  ****     Tel_ist=Tel_soll;
 210              		.loc 1 253 0
 211 0198 34409FE5 		ldr	r4, .L12
 212 019c 046084E5 		str	r6, [r4, #4]
 254:Dreh_motor.c  ****     Tel_referenz=cOutputGetCount(1);
 213              		.loc 1 254 0
 214 01a0 0100A0E3 		mov	r0, #1
 215 01a4 FEFFFFEB 		bl	cOutputGetCount
 216              	.LVL26:
 217 01a8 0010A0E1 		mov	r1, r0
 218 01ac 000084E5 		str	r0, [r4]
 255:Dreh_motor.c  ****     
 256:Dreh_motor.c  ****     printf("Tel_referenz:%d \n\r",Tel_referenz);
 219              		.loc 1 256 0
 220 01b0 28009FE5 		ldr	r0, .L12+12
 221 01b4 FEFFFFEB 		bl	printf
 222              	.LVL27:
 257:Dreh_motor.c  ****     printf("Tel_ist: %d\n\r",Tel_ist);
 223              		.loc 1 257 0
 224 01b8 24009FE5 		ldr	r0, .L12+16
 225 01bc 041094E5 		ldr	r1, [r4, #4]
 226 01c0 FEFFFFEB 		bl	printf
 227              	.LVL28:
 258:Dreh_motor.c  ****     sleep(1);
 228              		.loc 1 258 0
 229 01c4 0100A0E3 		mov	r0, #1
 230 01c8 FEFFFFEB 		bl	sleep
 231              	.LVL29:
 259:Dreh_motor.c  **** #endif
 260:Dreh_motor.c  ****     return 0;
 261:Dreh_motor.c  **** }
 232              		.loc 1 261 0
 233 01cc 0000A0E3 		mov	r0, #0
 234 01d0 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 235              	.L13:
 236              		.align	2
 237              	.L12:
 238 01d4 00000000 		.word	.LANCHOR0
 239 01d8 00000000 		.word	.LANCHOR1
 240 01dc 10270000 		.word	10000
 241 01e0 00000000 		.word	.LC0
 242 01e4 14000000 		.word	.LC1
 243              		.cfi_endproc
 244              	.LFE12:
 245              		.fnend
 247              		.align	2
 248              		.global	DrehTel_init
 250              	DrehTel_init:
 251              		.fnstart
 252              	.LFB11:
  37:Dreh_motor.c  **** // /Users/yangchunxia/Documents/Cube3*3/lms2012/c_output.h
 253              		.loc 1 37 0
 254              		.cfi_startproc
 255              		@ args = 0, pretend = 0, frame = 0
 256              		@ frame_needed = 0, uses_anonymous_args = 0
 257 01e8 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 258              		.save {r3, r4, r5, lr}
 259              		.cfi_def_cfa_offset 16
 260              		.cfi_offset 3, -16
 261              		.cfi_offset 4, -12
 262              		.cfi_offset 5, -8
 263              		.cfi_offset 14, -4
  55:Dreh_motor.c  **** #endif
 264              		.loc 1 55 0
 265 01ec FEFFFFEB 		bl	cOutputInit
 266              	.LVL30:
  57:Dreh_motor.c  ****     printf("DrehTeller_referenz Position angefahren: %d\n\r",Tel_referenz);
 267              		.loc 1 57 0
 268 01f0 0100A0E3 		mov	r0, #1
 269 01f4 FEFFFFEB 		bl	cOutputGetCount
 270              	.LVL31:
 271 01f8 0010A0E1 		mov	r1, r0
 272 01fc 20509FE5 		ldr	r5, .L15
 273 0200 000085E5 		str	r0, [r5]
  58:Dreh_motor.c  ****     Tel_ist=0;
 274              		.loc 1 58 0
 275 0204 1C009FE5 		ldr	r0, .L15+4
 276 0208 FEFFFFEB 		bl	printf
 277              	.LVL32:
  59:Dreh_motor.c  ****     DrehTel_setpos(0);
 278              		.loc 1 59 0
 279 020c 0040A0E3 		mov	r4, #0
 280 0210 044085E5 		str	r4, [r5, #4]
  60:Dreh_motor.c  **** #endif
 281              		.loc 1 60 0
 282 0214 0400A0E1 		mov	r0, r4
 283 0218 FEFFFFEB 		bl	DrehTel_setpos
 284              	.LVL33:
  63:Dreh_motor.c  **** 
 285              		.loc 1 63 0
 286 021c 0400A0E1 		mov	r0, r4
 287 0220 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 288              	.L16:
 289              		.align	2
 290              	.L15:
 291 0224 00000000 		.word	.LANCHOR0
 292 0228 24000000 		.word	.LC2
 293              		.cfi_endproc
 294              	.LFE11:
 295              		.fnend
 297              		.align	2
 298              		.global	DrehTel_dreh
 300              	DrehTel_dreh:
 301              		.fnstart
 302              	.LFB13:
 262:Dreh_motor.c  **** #ifdef __linux__
 263:Dreh_motor.c  **** int DrehTel_dreh(){
 303              		.loc 1 263 0
 304              		.cfi_startproc
 305              		@ args = 0, pretend = 0, frame = 0
 306              		@ frame_needed = 0, uses_anonymous_args = 0
 307 022c 04E02DE5 		str	lr, [sp, #-4]!
 308              		.save {lr}
 309              		.cfi_def_cfa_offset 4
 310              		.cfi_offset 14, -4
 311              		.pad #12
 312 0230 0CD04DE2 		sub	sp, sp, #12
 313              		.cfi_def_cfa_offset 16
 264:Dreh_motor.c  **** #if 0
 265:Dreh_motor.c  ****     char motor_command[4];
 266:Dreh_motor.c  ****     motor_command[0]=opOUTPUT_SPEED;
 267:Dreh_motor.c  ****     motor_command[1]=MOTOR_PORT_B;
 268:Dreh_motor.c  ****     motor_command[2]=MOTOR_SPEED_B;
 269:Dreh_motor.c  ****     write(motor_file,motor_command,3);
 270:Dreh_motor.c  ****     
 271:Dreh_motor.c  ****     motor_command[0]=opOUTPUT_START;
 272:Dreh_motor.c  ****     motor_command[1]=MOTOR_PORT_B;
 273:Dreh_motor.c  ****     write(motor_file,motor_command,2);
 274:Dreh_motor.c  ****     
 275:Dreh_motor.c  ****     int oldTachosensor=OutputInstance.MotorData[1].TachoSensor;
 276:Dreh_motor.c  ****     while (cOutputGetCount(3).TachoSensor-oldTachosensor<135) {
 277:Dreh_motor.c  ****         usleep(100);
 278:Dreh_motor.c  ****     }
 279:Dreh_motor.c  ****     motor_command[0]=opOUTPUT_STOP;
 280:Dreh_motor.c  ****     motor_command[1]=MOTOR_PORT_B;
 281:Dreh_motor.c  ****     motor_command[2]=1;  //break
 282:Dreh_motor.c  ****     write(motor_file,motor_command,3);
 283:Dreh_motor.c  **** #else
 284:Dreh_motor.c  ****     cOutputStepSpeed(MOTOR_PORT_B,MOTOR_SPEED_B, 15,105,15,1);
 314              		.loc 1 284 0
 315 0234 0F20A0E3 		mov	r2, #15
 316 0238 00208DE5 		str	r2, [sp]
 317 023c 0130A0E3 		mov	r3, #1
 318 0240 04308DE5 		str	r3, [sp, #4]
 319 0244 0200A0E3 		mov	r0, #2
 320 0248 2310A0E3 		mov	r1, #35
 321 024c 6930A0E3 		mov	r3, #105
 322 0250 FEFFFFEB 		bl	cOutputStepSpeed
 323              	.LVL34:
 285:Dreh_motor.c  **** #endif
 286:Dreh_motor.c  ****     
 287:Dreh_motor.c  ****     return 0;
 288:Dreh_motor.c  **** }
 324              		.loc 1 288 0
 325 0254 0000A0E3 		mov	r0, #0
 326 0258 0CD08DE2 		add	sp, sp, #12
 327              		@ sp needed
 328 025c 04F09DE4 		ldr	pc, [sp], #4
 329              		.cfi_endproc
 330              	.LFE13:
 331              		.fnend
 333              		.align	2
 334              		.global	DrehTel_close
 336              	DrehTel_close:
 337              		.fnstart
 338              	.LFB14:
 289:Dreh_motor.c  **** 
 290:Dreh_motor.c  **** 
 291:Dreh_motor.c  **** int DrehTel_close(){
 339              		.loc 1 291 0
 340              		.cfi_startproc
 341              		@ args = 0, pretend = 0, frame = 0
 342              		@ frame_needed = 0, uses_anonymous_args = 0
 343 0260 08402DE9 		stmfd	sp!, {r3, lr}
 344              		.save {r3, lr}
 345              		.cfi_def_cfa_offset 8
 346              		.cfi_offset 3, -8
 347              		.cfi_offset 14, -4
 292:Dreh_motor.c  **** #if 0
 293:Dreh_motor.c  ****     char motor_command[4];
 294:Dreh_motor.c  ****     motor_command[0] = opOUTPUT_STOP;
 295:Dreh_motor.c  ****     motor_command[1] = MOTOR_PORT_B;
 296:Dreh_motor.c  ****     motor_command[2] = 0;
 297:Dreh_motor.c  ****     write(motor_file,motor_command,3);
 298:Dreh_motor.c  ****     close(encoder_file);
 299:Dreh_motor.c  ****     close(motor_file);
 300:Dreh_motor.c  **** #else
 301:Dreh_motor.c  ****     cOutputExit();
 348              		.loc 1 301 0
 349 0264 FEFFFFEB 		bl	cOutputExit
 350              	.LVL35:
 302:Dreh_motor.c  **** #endif
 303:Dreh_motor.c  ****     return 0;
 304:Dreh_motor.c  **** }
 351              		.loc 1 304 0
 352 0268 0000A0E3 		mov	r0, #0
 353 026c 0880BDE8 		ldmfd	sp!, {r3, pc}
 354              		.cfi_endproc
 355              	.LFE14:
 356              		.fnend
 358              		.global	dreh_Korr_Winkel
 359              		.global	dreh_winkel
 360              		.global	Tel_referenz
 361              		.global	Tel_ist
 362              		.comm	OutputInstance,64,4
 363              		.global	MOTOR_PORT_B
 364              		.global	MOTOR_SPEED_B
 365              		.section	.rodata
 366              		.align	2
 367              	.LANCHOR1 = . + 0
 370              	dreh_winkel:
 371 0000 00000000 		.word	0
 372 0004 0E010000 		.word	270
 373 0008 F2FEFFFF 		.word	-270
 374 000c 1C020000 		.word	540
 375 0010 E4FDFFFF 		.word	-540
 378              	dreh_Korr_Winkel:
 379 0014 0A000000 		.word	10
 382              	MOTOR_PORT_B:
 383 0018 02       		.byte	2
 384 0019 000000   		.space	3
 387              	MOTOR_SPEED_B:
 388 001c 23000000 		.word	35
 389              		.section	.rodata.str1.4,"aMS",%progbits,1
 390              		.align	2
 391              	.LC0:
 392 0000 54656C5F 		.ascii	"Tel_referenz:%d \012\015\000"
 392      72656665 
 392      72656E7A 
 392      3A256420 
 392      0A0D00
 393 0013 00       		.space	1
 394              	.LC1:
 395 0014 54656C5F 		.ascii	"Tel_ist: %d\012\015\000"
 395      6973743A 
 395      2025640A 
 395      0D00
 396 0022 0000     		.space	2
 397              	.LC2:
 398 0024 44726568 		.ascii	"DrehTeller_referenz Position angefahren: %d\012\015"
 398      54656C6C 
 398      65725F72 
 398      65666572 
 398      656E7A20 
 399 0051 00       		.ascii	"\000"
 400 0052 0000     		.bss
 401              		.align	2
 402              	.LANCHOR0 = . + 0
 405              	Tel_referenz:
 406 0000 00000000 		.space	4
 409              	Tel_ist:
 410 0004 00000000 		.space	4
 411              		.text
 412              	.Letext0:
 413              		.file 2 "/usr/local/carlson-minot/crosscompilers/arm-none-linux-gnueabi/libc-2014.05-29-sysroot/us
 414              		.file 3 "/usr/local/carlson-minot/crosscompilers/lib/gcc/arm-none-linux-gnueabi/4.8.3/include/stdd
 415              		.file 4 "/usr/local/carlson-minot/crosscompilers/arm-none-linux-gnueabi/libc-2014.05-29-sysroot/us
 416              		.file 5 "lmstypes.h"
 417              		.file 6 "bytecodes.h"
 418              		.file 7 "lms2012.h"
 419              		.file 8 "../lms2012/c_output.h"
 420              		.file 9 "/usr/local/carlson-minot/crosscompilers/arm-none-linux-gnueabi/libc-2014.05-29-sysroot/us
 421              		.file 10 "/usr/local/carlson-minot/crosscompilers/arm-none-linux-gnueabi/libc-2014.05-29-sysroot/u
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Dreh_motor.c
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:16     .text:0000000000000000 $a
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:19     .text:0000000000000000 DrehTel_setpos
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:238    .text:00000000000001d4 $d
                       .ARM.exidx:0000000000000000 $d
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:247    .text:00000000000001e8 $a
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:250    .text:00000000000001e8 DrehTel_init
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:291    .text:0000000000000224 $d
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:297    .text:000000000000022c $a
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:300    .text:000000000000022c DrehTel_dreh
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:336    .text:0000000000000260 DrehTel_close
                       .ARM.extab:0000000000000000 $d
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:378    .rodata:0000000000000014 dreh_Korr_Winkel
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:370    .rodata:0000000000000000 dreh_winkel
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:405    .bss:0000000000000000 Tel_referenz
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:409    .bss:0000000000000004 Tel_ist
                            *COM*:0000000000000040 OutputInstance
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:382    .rodata:0000000000000018 MOTOR_PORT_B
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:387    .rodata:000000000000001c MOTOR_SPEED_B
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:366    .rodata:0000000000000000 $d
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:390    .rodata.str1.4:0000000000000000 $d
/var/folders/x0/118sfpkj75v4t4_qgl0ndwr00000gn/T//ccxhG7Bi.s:401    .bss:0000000000000000 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
cOutputGetCount
cOutputSpeed
cOutputStart
usleep
cOutputStop
printf
sleep
__aeabi_unwind_cpp_pr0
cOutputInit
cOutputStepSpeed
cOutputExit
__aeabi_unwind_cpp_pr1
